<!DOCTYPE html>
<html>
<head>
    <title>Aquiplicity 2025 (Align, Threshold, Lasso, Brush - V3)</title>
    <style>
        /* CSS Styles (Removed Overlay Canvas Style) */
        body {
            margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; font-family: Arial, sans-serif; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
        }
        #marqueeContainer { position: fixed; top: 0; left: 0; width: 100%; background: #f0f0f0; border-bottom: 1px solid #ccc; overflow: hidden; height: 20px; z-index: 1000; }
        #marquee { font-size: 12px; white-space: nowrap; animation: scroll 50s linear infinite; display: inline-block; padding-left: 100%; }
        @keyframes scroll { 0% { transform: translateX(0%); } 100% { transform: translateX(-300%); } }
        #controls { display: flex; align-items: center; padding: 10px; flex-wrap: wrap; margin-top: 20px; background: #f8f8f8; border-bottom: 1px solid #ccc; }
        #mainContainer { display: flex; flex: 1; overflow: hidden; }
        #thumbnailStrip { display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; padding: 5px; border-right: 1px solid #ccc; background: #f0f0f0; width: 165px; flex-shrink: 0; }

        /* --- Thumbnail Container --- */
        .thumbnail-container {
            position: relative;
            width: 150px;
            height: 112px;
            margin-bottom: 5px;
            display: inline-block;
            border: 1px solid transparent;
            transition: border-color 0.2s ease;
        }
        /* Removed Ref class, only Target needed for new workflow */
        .thumbnail-container.selected-for-align-tgt { border-color: #ffc107; border-width: 2px; }

        .thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 1px solid #999;
            cursor: pointer;
            background-color: #fff;
            display: block;
        }
        .thumbnail:hover { border-color: #000; box-shadow: 0 0 5px rgba(0,0,0,0.3); }

        /* --- Thumbnail Remove Button --- */
        .remove-thumbnail-btn {
            position: absolute;
            top: 1px;
            right: 1px;
            width: 18px;
            height: 18px;
            background-color: rgba(204, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(150, 0, 0, 0.8);
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            line-height: 16px;
            text-align: center;
            display: none;
            z-index: 10;
            transition: background-color 0.2s ease;
            padding: 0;
        }
        .thumbnail-container:hover .remove-thumbnail-btn {
            display: block;
        }
        .remove-thumbnail-btn:hover {
            background-color: rgba(255, 0, 0, 0.9);
            border-color: rgba(100, 0, 0, 1);
        }
        .remove-thumbnail-btn:active {
             transform: scale(0.95);
        }
        /* --- END Thumbnail Styles --- */

        #workingArea {
            flex: 1; display: flex; flex-direction: column; align-items: center;
            overflow-y: auto; overflow-x: hidden;
            padding: 10px; background: #e9e9e9; position: relative;
        }
        canvas { /* This is now the ONLY canvas */
            border: 1px solid black;
            background-color: white; /* Default background */
            max-width: 100%;
            max-height: calc(100% - 60px);
            display: block;
            object-fit: contain;
            cursor: crosshair;
            box-sizing: border-box;
        }
        /* Removed #manualAlignOverlay style block */

        #status { margin: 5px; font-size: 14px; text-align: center; flex-shrink: 0; min-height: 1.2em; color: #333; width: 100%; }
        button, input[type="file"]::file-selector-button, select { margin: 5px; padding: 5px 10px; font-size: 12px; border-radius: 3px; cursor: pointer; transition: background-color 0.2s ease, box-shadow 0.1s ease; border: 1px solid #ccc; background-color: #f0f0f0; }
        input[type="file"]::file-selector-button:hover, button:hover:not(:disabled), select:hover:not(:disabled) { background-color: #e0e0e0; }
        select { padding: 4px 8px; height: 28px; }
        .slider-container { margin: 0 10px; display: flex; align-items: center; }
        .slider-label, .control-label { margin-right: 5px; font-size: 12px; white-space: nowrap; }
        input[type="range"] { width: 80px; height: 5px; cursor: pointer; }
        .slider-value { margin-left: 5px; min-width: 35px; font-size: 12px; text-align: right; }
        .tracy-rose-button, .reset-button, .action-button, .align-button { color: white; padding: 4px 8px; border: none; box-shadow: 0 2px 2px rgba(0,0,0,0.2); font-family: Arial, sans-serif; font-size: 12px; transition: all 0.1s; margin: 0 5px; }
        .tracy-rose-button:active, .reset-button:active, .action-button:active, .align-button:active { box-shadow: 0 1px 1px rgba(0,0,0,0.2); transform: translateY(1px); }
        .tracy-rose-button:disabled, .reset-button:disabled, .action-button:disabled, .align-button:disabled { background-color: #cccccc !important; color: #666666; cursor: not-allowed; box-shadow: none; transform: none; }
        .tracy-rose-button { background-color: #0066cc; } .tracy-rose-button:hover:not(:disabled) { background-color: #0077e6; }
        .reset-button { background-color: #cc0000; } .reset-button:hover:not(:disabled) { background-color: #e60000; }
        .action-button { background-color: #5cb85c; } .action-button:hover:not(:disabled) { background-color: #6cd96c; }
        .align-button { background-color: #ffae42; } .align-button:hover:not(:disabled) { background-color: #ffb75e; } /* Orange for align */
        #canvasButtonContainer { display: flex; justify-content: center; margin-top: 10px; flex-shrink: 0; width: 100%; }

        /* Alignment specific controls */
        #alignmentControls { border-top: 1px solid #ccc; margin-top: 10px; padding-top: 10px; display: flex; flex-wrap: wrap; align-items: center; }
        #manualAlignControls { display: flex; flex-wrap: wrap; align-items: center; margin-left: 15px; padding-left: 15px; border-left: 1px dashed #ccc; }
        .manual-nudge-button { font-size: 14px; padding: 2px 6px; width: 25px; height: 25px; line-height: 1; margin: 1px; }
        #manualAlignStatus { font-size: 11px; margin-left: 10px; color: #555; min-width: 100px; }
    </style>
</head>
<body>
    <!-- Marquee and Controls -->
    <div id="marqueeContainer"><div id="marquee">NEW: Align Images! Use Auto-Align or Manual Nudge (Click thumb > 0, use arrows/buttons). Compose uses offsets. Patch (Ctrl+Drag) / Blend (Alt+Drag) / Gradient (Shift+Drag) / Patch Brush (Click) / Undo.</div></div>
    <div id="controls">
        <input type="file" id="imageInput" multiple accept="image/*">
        <button id="composeButton" class="action-button" onclick="composeImages()" disabled>Compose!</button>
        <button id="undoButton" class="action-button" onclick="undoAction()" disabled>Undo</button>
        <button class="reset-button" onclick="resetApplication()">Reset</button>
        <div class="slider-container">
            <span class="slider-label">Threshold (% Diff):</span>
            <input type="range" id="threshold" min="0.01" max="1.0" step="0.01" value="0.15">
            <span class="slider-value" id="threshold-value">15%</span>
        </div>
         <div class="slider-container">
            <span class="slider-label">Brush Size (px):</span>
            <input type="range" id="brushSize" min="4" max="200" step="2" value="100">
            <span class="slider-value" id="brushSize-value">100px</span>
        </div>
        <button class="tracy-rose-button" onclick="setTracyRosePreset()">By Tracy Rose</button>

        <!-- Alignment Controls -->
        <div id="alignmentControls">
             <span class="control-label">Alignment:</span>
             <input type="checkbox" id="autoAlignCheckbox" checked title="Automatically align new images to the first image on load">
             <label for="autoAlignCheckbox" style="font-size: 12px; margin-right: 5px;">Auto</label>
             <button id="alignNowButton" class="align-button" onclick="runAutoAlignment()" disabled title="Run automatic alignment on all images relative to the first">Align All Now</button>
             <button id="resetOffsetsButton" class="reset-button" onclick="resetAllOffsets()" disabled title="Reset all alignment offsets to zero">Reset Offsets</button>

             <!-- Simplified Manual Controls -->
             <div id="manualAlignControls">
                 <span class="control-label">Manual Align:</span>
                 <!-- Removed Ref dropdown -->
                 <select id="manualTgtImage" disabled title="Select Image to Align Manually (to layer below)"></select>
                 <button id="manualNudgeUp" class="manual-nudge-button align-button" onclick="nudgeManualAlign(0, -1)" disabled>↑</button>
                 <button id="manualNudgeDown" class="manual-nudge-button align-button" onclick="nudgeManualAlign(0, 1)" disabled>↓</button>
                 <button id="manualNudgeLeft" class="manual-nudge-button align-button" onclick="nudgeManualAlign(-1, 0)" disabled>←</button>
                 <button id="manualNudgeRight" class="manual-nudge-button align-button" onclick="nudgeManualAlign(1, 0)" disabled>→</button>
                 <button id="manualApplyOffset" class="action-button" onclick="applyManualOffset()" disabled style="font-size: 10px; padding: 3px 6px;">Apply</button>
                 <button id="manualResetOffset" class="reset-button" onclick="resetCurrentManualOffset()" disabled style="font-size: 10px; padding: 3px 6px;">Reset</button>
                 <span id="manualAlignStatus">Select image (>0)</span>
             </div>
        </div>
    </div>
    <!-- Main Content -->
    <div id="mainContainer">
        <div id="thumbnailStrip"></div>
        <div id="workingArea">
            <!-- Removed Overlay Canvas -->
            <canvas id="canvasOutput"></canvas>
            <div id="canvasButtonContainer"><button id="saveButton" class="action-button" onclick="saveImage()" disabled>Save Master Image</button></div>
            <div id="status">Upload images to begin</div>
        </div>
    </div>

    <script type="text/javascript">
        // --- ImageStack Class (Unchanged from previous correct version) ---
        class ImageStack {
            constructor() {
                this.images = []; // Stores { imageData: ImageData, offset: { x: 0, y: 0 }, originalFile: File }
                this.width = 0;
                this.height = 0;
            }

            async addImage(file) {
                const img = new Image();
                const objectUrl = URL.createObjectURL(file);
                try {
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = (err) => reject(new Error(`Image load failed: ${file.name} - ${err.type || 'Unknown error'}`));
                        img.src = objectUrl;
                    });

                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d", { willReadFrequently: true });

                    if (this.images.length === 0) {
                        this.width = img.width;
                        this.height = img.height;
                        console.log(`Setting stack dimensions to ${this.width}x${this.height} based on first image: ${file.name}`);
                        if (this.width > 4000 || this.height > 4000) {
                            console.warn(`Warning: Processing large image resolution (${this.width}x${this.height}). This may be slow and use significant memory.`);
                            updateStatus(`Warning: Large resolution (${this.width}x${this.height}). Processing may be slow.`);
                        }
                    }

                    if (img.width !== this.width || img.height !== this.height) {
                         console.log(`Resizing image ${file.name} (${img.width}x${img.height}) to match stack dimensions (${this.width}x${this.height})`);
                    }
                    canvas.width = this.width;
                    canvas.height = this.height;

                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // Ensure alpha is opaque for consistency
                    for (let i = 3; i < imageData.data.length; i += 4) {
                        imageData.data[i] = 255;
                    }

                    this.images.push({
                        imageData: imageData,
                        offset: { x: 0, y: 0 }, // Initialize offset
                        originalFile: file // Store file reference for names etc.
                    });
                    console.log(`Added image ${file.name} (${imageData.width}x${imageData.height}) to stack. Total: ${this.images.length}`);
                } finally {
                    URL.revokeObjectURL(objectUrl);
                }
            }

             async calculateOffset(refImageData, currentImageData, searchRadius = 30) {
                const w = refImageData.width;
                const h = refImageData.height;
                const patchSize = Math.min(128, Math.floor(w / 4), Math.floor(h / 4));
                 const actualPatchSize = patchSize > 0 ? patchSize : 32;
                const patchStartX = Math.floor(w / 2 - actualPatchSize / 2);
                const patchStartY = Math.floor(h / 2 - actualPatchSize / 2);

                 if (patchStartX < 0 || patchStartY < 0 || patchStartX + actualPatchSize > w || patchStartY + actualPatchSize > h || actualPatchSize <= 0) {
                     console.warn("Cannot calculate offset: Invalid patch dimensions or image too small.");
                     return { x: 0, y: 0 };
                 }

                const refData = refImageData.data;
                const currentData = currentImageData.data;

                const refPatch = new Float32Array(actualPatchSize * actualPatchSize);
                let refMean = 0;
                for (let y = 0; y < actualPatchSize; y++) {
                    for (let x = 0; x < actualPatchSize; x++) {
                        const idx = ((patchStartY + y) * w + (patchStartX + x)) * 4;
                        const lum = 0.299 * refData[idx] + 0.587 * refData[idx + 1] + 0.114 * refData[idx + 2];
                        refPatch[y * actualPatchSize + x] = lum;
                        refMean += lum;
                    }
                }
                refMean /= (actualPatchSize * actualPatchSize);

                let refStdDev = 0;
                for (let i = 0; i < refPatch.length; i++) {
                    refPatch[i] -= refMean;
                    refStdDev += refPatch[i] * refPatch[i];
                }
                refStdDev = Math.sqrt(refStdDev);
                if (refStdDev < 1e-6) {
                    console.warn("Reference patch is too flat for alignment.");
                    return { x: 0, y: 0 };
                }

                let bestCorr = -Infinity;
                let bestDx = 0;
                let bestDy = 0;

                const searchStartX = Math.max(0, patchStartX - searchRadius);
                const searchStartY = Math.max(0, patchStartY - searchRadius);
                const searchEndX = Math.min(w - actualPatchSize, patchStartX + searchRadius);
                const searchEndY = Math.min(h - actualPatchSize, patchStartY + searchRadius);

                for (let sy = searchStartY; sy <= searchEndY; sy++) {
                    for (let sx = searchStartX; sx <= searchEndX; sx++) {
                        let currentMean = 0;
                        let currentPatchValues = [];
                        for (let py = 0; py < actualPatchSize; py++) {
                            for (let px = 0; px < actualPatchSize; px++) {
                                const idx = ((sy + py) * w + (sx + px)) * 4;
                                if (idx + 2 < currentData.length) {
                                    const lum = 0.299 * currentData[idx] + 0.587 * currentData[idx + 1] + 0.114 * currentData[idx + 2];
                                    currentPatchValues.push(lum);
                                    currentMean += lum;
                                } else {
                                    currentPatchValues.push(0);
                                }
                            }
                        }
                        currentMean /= (actualPatchSize * actualPatchSize);

                        let currentStdDev = 0;
                        let crossCorr = 0;
                        for (let i = 0; i < refPatch.length; i++) {
                             const currentValNorm = currentPatchValues[i] - currentMean;
                             currentStdDev += currentValNorm * currentValNorm;
                             crossCorr += refPatch[i] * currentValNorm;
                        }
                        currentStdDev = Math.sqrt(currentStdDev);

                        if (currentStdDev < 1e-6) continue;

                        const normCorr = crossCorr / (refStdDev * currentStdDev);

                        if (normCorr > bestCorr) {
                            bestCorr = normCorr;
                            bestDx = sx - patchStartX;
                            bestDy = sy - patchStartY;
                        }
                    }
                     if (sy % 10 === 0) await new Promise(resolve => setTimeout(resolve, 0));
                }
                console.log(`Alignment offset calculated: dx=${bestDx}, dy=${bestDy}, corr=${bestCorr.toFixed(4)}`);
                 bestDx = Math.max(-searchRadius-1, Math.min(searchRadius+1, bestDx));
                 bestDy = Math.max(-searchRadius-1, Math.min(searchRadius+1, bestDy));
                return { x: Math.round(bestDx), y: Math.round(bestDy) };
            }

            async alignStackToReference(refIndex = 0, searchRadius = 30) {
                if (this.images.length < 2 || refIndex < 0 || refIndex >= this.images.length) {
                     console.warn("alignStackToReference: Not enough images or invalid reference index.");
                     return;
                }
                const referenceImage = this.images[refIndex].imageData;
                if (!referenceImage) {
                    console.error("alignStackToReference: Reference image data not found.");
                    return;
                }
                updateStatus(`Starting auto-alignment (Ref: ${refIndex})...`);
                for (let i = 0; i < this.images.length; i++) {
                     if (i === refIndex) {
                         this.images[i].offset = { x: 0, y: 0 };
                         continue;
                     }
                      if (!this.images[i].imageData) {
                          console.warn(`Skipping alignment for image ${i}: Missing imageData.`);
                          this.images[i].offset = { x: 0, y: 0 };
                          continue;
                      }
                     updateStatus(`Aligning image ${i+1}/${this.images.length} to reference ${refIndex+1}...`);
                     await new Promise(resolve => setTimeout(resolve, 0));
                     try {
                        const offset = await this.calculateOffset(referenceImage, this.images[i].imageData, searchRadius);
                        this.setOffset(i, offset);
                        console.log(`Image ${i} aligned with offset: ${JSON.stringify(this.images[i].offset)}`);
                     } catch (alignError) {
                         console.error(`Error aligning image ${i}:`, alignError);
                         this.setOffset(i, {x: 0, y: 0});
                         updateStatus(`Error aligning image ${i+1}. Setting offset to (0,0).`, true);
                     }
                }
                 updateStatus(`Auto-alignment complete. ${this.images.length} images processed.`);
                 updateManualAlignmentUI();
            }

            resetAllOffsets() {
                 this.images.forEach(imgData => imgData.offset = { x: 0, y: 0 });
                 console.log("All image offsets reset to {x: 0, y: 0}");
                 updateManualAlignmentUI();
            }

            getOffset(index) {
                return (this.images[index] && this.images[index].offset) ? { ...this.images[index].offset } : { x: 0, y: 0 };
            }

            setOffset(index, offset) {
                if (this.images[index]) {
                    this.images[index].offset = { x: Math.round(offset.x), y: Math.round(offset.y) };
                    console.log(`Offset for image ${index} set to ${JSON.stringify(this.images[index].offset)}`);
                }
            }

            smoothLayer(imageData, iterations = 6) { if (!imageData) return null; const data = new Float32Array(imageData.data); const temp = new Float32Array(data.length); const width = imageData.width; const height = imageData.height; for (let iter = 0; iter < iterations; iter++) { for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const idx = (y * width + x) * 4; if (x === 0 || x === width - 1 || y === 0 || y === height - 1) { for (let c = 0; c < 4; c++) { temp[idx + c] = data[idx + c]; } } else { for (let c = 0; c < 3; c++) { temp[idx + c] = ( data[((y - 1) * width + x) * 4 + c] + data[((y + 1) * width + x) * 4 + c] + data[(y * width + (x - 1)) * 4 + c] + data[(y * width + (x + 1)) * 4 + c] ) / 4; } temp[idx + 3] = data[idx + 3]; } } } data.set(temp); } const result = new Uint8ClampedArray(data.length); for (let i = 0; i < data.length; i++) { result[i] = Math.round(Math.min(255, Math.max(0, data[i]))); } return new ImageData(result, width, height); }

            colorDistance(r1, g1, b1, r2, g2, b2) { const dr = r1 - r2; const dg = g1 - g2; const db = b1 - b2; return Math.sqrt(dr * dr + dg * dg + db * db); }

            async compose(threshold) {
                if (this.images.length < 2) { throw new Error("Need at least two images"); }
                const percentageThreshold = (threshold / 255 * 100).toFixed(0);
                console.log("Starting composition with", this.images.length, "images and threshold:", threshold, `(~${percentageThreshold}%)`); console.log(`Composition dimensions: ${this.width}x${this.height}`);

                updateStatus("Smoothing layers..."); await new Promise(resolve => setTimeout(resolve, 10));
                const smoothedLayers = [];
                for (let i = 0; i < this.images.length; i++) {
                    updateStatus(`Smoothing layer ${i+1} of ${this.images.length}...`); await new Promise(resolve => setTimeout(resolve, 0));
                    smoothedLayers.push(this.smoothLayer(this.images[i].imageData));
                    if (!smoothedLayers[i]) { throw new Error(`Smoothing failed for layer ${i}`); }
                }
                console.log(`${smoothedLayers.length} layers smoothed.`);

                const masterImageDataBuffer = new Uint8ClampedArray(this.width * this.height * 4);
                const layerMatrix = new Uint8Array(this.width * this.height);

                updateStatus("Processing pixels (with alignment)..."); await new Promise(resolve => setTimeout(resolve, 10)); console.log("Processing pixels with alignment...");
                const w = this.width; const h = this.height; const totalPixels = w * h;
                let processedPixels = 0;
                const yieldPixelInterval = 30000;

                const baseOffset = this.images[0].offset;
                const baseSmoothedData = smoothedLayers[0].data;

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const targetIdx = (y * w + x) * 4;

                        const baseX_s = x - baseOffset.x;
                        const baseY_s = y - baseOffset.y;
                        let baseR_s = 0, baseG_s = 0, baseB_s = 0;
                        if (baseX_s >= 0 && baseX_s < w && baseY_s >= 0 && baseY_s < h) {
                            const baseSourceIdx_s = (baseY_s * w + baseX_s) * 4;
                            if (baseSourceIdx_s + 2 < baseSmoothedData.length) {
                                baseR_s = baseSmoothedData[baseSourceIdx_s];
                                baseG_s = baseSmoothedData[baseSourceIdx_s + 1];
                                baseB_s = baseSmoothedData[baseSourceIdx_s + 2];
                            }
                        }

                        let bestLayerIndex = 0;

                        for (let layerIdx = this.images.length - 1; layerIdx >= 1; layerIdx--) {
                            const currentOffset = this.images[layerIdx].offset;
                            const currentPixelData_s = smoothedLayers[layerIdx].data;
                            const currentX_s = x - currentOffset.x;
                            const currentY_s = y - currentOffset.y;

                            if (currentX_s >= 0 && currentX_s < w && currentY_s >= 0 && currentY_s < h) {
                                const currentSourceIdx_s = (currentY_s * w + currentX_s) * 4;
                                if (currentSourceIdx_s + 2 < currentPixelData_s.length) {
                                    const currentR_s = currentPixelData_s[currentSourceIdx_s];
                                    const currentG_s = currentPixelData_s[currentSourceIdx_s + 1];
                                    const currentB_s = currentPixelData_s[currentSourceIdx_s + 2];
                                    const dist = this.colorDistance(currentR_s, currentG_s, currentB_s, baseR_s, baseG_s, baseB_s);
                                    if (dist > threshold) {
                                        bestLayerIndex = layerIdx;
                                        break;
                                    }
                                }
                            }
                        }

                        const finalOffset = this.images[bestLayerIndex].offset;
                        const finalSourceImageData = this.images[bestLayerIndex].imageData.data;
                        const finalSourceX = x - finalOffset.x;
                        const finalSourceY = y - finalOffset.y;

                        if (finalSourceX >= 0 && finalSourceX < w && finalSourceY >= 0 && finalSourceY < h) {
                            const finalSourceIdx = (finalSourceY * w + finalSourceX) * 4;
                            if (finalSourceIdx + 3 < finalSourceImageData.length) {
                                masterImageDataBuffer[targetIdx]     = finalSourceImageData[finalSourceIdx];
                                masterImageDataBuffer[targetIdx + 1] = finalSourceImageData[finalSourceIdx + 1];
                                masterImageDataBuffer[targetIdx + 2] = finalSourceImageData[finalSourceIdx + 2];
                                masterImageDataBuffer[targetIdx + 3] = finalSourceImageData[finalSourceIdx + 3];
                            } else {
                                masterImageDataBuffer[targetIdx] = 0; masterImageDataBuffer[targetIdx+1] = 0; masterImageDataBuffer[targetIdx+2] = 0; masterImageDataBuffer[targetIdx+3] = 255;
                            }
                        } else {
                            const baseOriginalData = this.images[0].imageData.data;
                             const baseOriginalX = x - baseOffset.x;
                             const baseOriginalY = y - baseOffset.y;
                             if (baseOriginalX >= 0 && baseOriginalX < w && baseOriginalY >= 0 && baseOriginalY < h) {
                                const baseOriginalIdx = (baseOriginalY * w + baseOriginalX) * 4;
                                 if (baseOriginalIdx + 3 < baseOriginalData.length) {
                                    masterImageDataBuffer[targetIdx]     = baseOriginalData[baseOriginalIdx];
                                    masterImageDataBuffer[targetIdx + 1] = baseOriginalData[baseOriginalIdx + 1];
                                    masterImageDataBuffer[targetIdx + 2] = baseOriginalData[baseOriginalIdx + 2];
                                    masterImageDataBuffer[targetIdx + 3] = baseOriginalData[baseOriginalIdx + 3];
                                 } else {
                                     masterImageDataBuffer[targetIdx] = 0; masterImageDataBuffer[targetIdx+1] = 0; masterImageDataBuffer[targetIdx+2] = 0; masterImageDataBuffer[targetIdx+3] = 255;
                                 }
                             } else {
                                masterImageDataBuffer[targetIdx] = 0; masterImageDataBuffer[targetIdx+1] = 0; masterImageDataBuffer[targetIdx+2] = 0; masterImageDataBuffer[targetIdx+3] = 255;
                             }
                        }

                        layerMatrix[y * w + x] = bestLayerIndex;
                        processedPixels++;

                        if (processedPixels % yieldPixelInterval === 0) {
                            const progress = Math.round((processedPixels / totalPixels) * 100);
                            updateStatus(`Processing pixels (with alignment)... (${progress}%)`);
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }

                    } // End x loop
                } // End y loop

                console.log("Composition completed.");
                return { imageData: new ImageData(masterImageDataBuffer, w, h), layerMatrix };
            }
             // --- End ImageStack Class ---
        }

        // --- Global Variables ---
        const MAX_HISTORY = 15;
        const BLEND_LASSO_RADIUS = 2;
        const GRADIENT_LASSO_OPACITY = 0.25;
        const MANUAL_ALIGN_VIEW_OPACITY = 0.8; // Opacity of the top image during manual align

        let canvas, ctx;
        // Removed manualAlignOverlayCanvas, manualAlignOverlayCtx
        let imageStack = new ImageStack();
        let statusEl, composeButton, thumbnailStrip, undoButton, saveButton;
        let masterImageData = null; let layerMatrix = null;
        let lassoPoints = []; let drawingLasso = false;
        let isPatchLasso = false; let isBlendLasso = false; let isGradientLasso = false;
        let historyStack = []; let isComposing = false; let isAligning = false;

        // Manual Alignment State - Simplified
        // Removed manualRefIndex
        let manualTgtIndex = -1; // Index of the image being aligned (>0)
        let manualCurrentNudge = { x: 0, y: 0 }; // Temporary nudge offset during manual adjustment


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('canvasOutput'); // The only canvas now
            ctx = canvas.getContext('2d', { willReadFrequently: true });

            statusEl = document.getElementById('status');
            composeButton = document.getElementById('composeButton');
            thumbnailStrip = document.getElementById('thumbnailStrip');
            undoButton = document.getElementById('undoButton');
            saveButton = document.getElementById('saveButton');
            // Removed checks for overlay canvas
            if (!canvas || !ctx || !composeButton) { updateStatus('Error: Core UI elements failed to load!', true); return; }

            document.getElementById('imageInput').addEventListener('change', handleImageUpload);
            setupCanvasEvents();
            setupKeyboardShortcuts();
            setupAlignmentControls();

            // Setup Threshold Slider
            const thresholdSlider = document.getElementById('threshold');
            const thresholdValueDisplay = document.getElementById('threshold-value');
            if (thresholdSlider && thresholdValueDisplay) {
                const updateThresholdDisplay = () => {
                     const percentage = (parseFloat(thresholdSlider.value) * 100).toFixed(0);
                     thresholdValueDisplay.textContent = percentage + '%';
                };
                thresholdSlider.addEventListener('input', updateThresholdDisplay);
                updateThresholdDisplay(); // Initial display
            }

            // Setup Brush Size Slider
            const brushSizeSlider = document.getElementById('brushSize');
            const brushSizeValueDisplay = document.getElementById('brushSize-value');
             if (brushSizeSlider && brushSizeValueDisplay) {
                 const updateBrushSizeDisplay = () => {
                      brushSizeValueDisplay.textContent = brushSizeSlider.value + 'px';
                 };
                brushSizeSlider.addEventListener('input', updateBrushSizeDisplay);
                updateBrushSizeDisplay(); // Initial display
            }

            updateUIStates();
            console.log('Aquiplicity 2025 Initialized (Align V3)');
        });

        // --- UI Update Functions ---
        function updateStatus(message, isError = false) { if (statusEl) { statusEl.textContent = message; statusEl.style.color = isError ? 'red' : '#333'; } if (isError) { console.error("Status:", message); } else { console.log("Status:", message); } }

        function updateUIStates() {
             const busy = isComposing || isAligning;
             const hasEnoughImages = imageStack.images.length >= 2;
             const hasMasterImage = masterImageData !== null;
             const hasAnyImages = imageStack.images.length > 0;

             if (composeButton) composeButton.disabled = busy || !hasEnoughImages;
             if (undoButton) undoButton.disabled = busy || historyStack.length === 0;
             if (saveButton) saveButton.disabled = busy || !hasMasterImage;

             document.body.style.cursor = busy ? 'wait' : 'default';
             // Only change canvas cursor if NOT in manual alignment mode
             canvas.style.cursor = (busy || manualTgtIndex > 0) ? (busy ? 'wait' : 'move') : 'crosshair';

             document.getElementById('threshold').disabled = busy;
             document.getElementById('brushSize').disabled = busy;
             if(document.getElementById('imageInput')) document.getElementById('imageInput').disabled = busy;

             if(document.querySelector('.reset-button')) document.querySelector('.reset-button').disabled = busy;
             if(document.querySelector('.tracy-rose-button')) document.querySelector('.tracy-rose-button').disabled = busy;
             document.querySelectorAll('.remove-thumbnail-btn').forEach(btn => btn.disabled = busy);

             const autoAlignCheckbox = document.getElementById('autoAlignCheckbox');
             const alignNowButton = document.getElementById('alignNowButton');
             const resetOffsetsButton = document.getElementById('resetOffsetsButton');
             if (autoAlignCheckbox) autoAlignCheckbox.disabled = busy;
             if (alignNowButton) alignNowButton.disabled = busy || !hasEnoughImages;
             if (resetOffsetsButton) resetOffsetsButton.disabled = busy || !hasAnyImages;

             updateManualAlignmentUI();
         }

        function setUIBusy(busyType = null) {
             isComposing = (busyType === 'composing');
             isAligning = (busyType === 'aligning');
             updateUIStates();
        }

        // --- Core Logic Functions ---
        function fitToScreen(imgWidth, imgHeight) { const container = document.getElementById('workingArea'); if (!container) return { width: imgWidth, height: imgHeight }; const containerStyle = window.getComputedStyle(container); const paddingX = parseFloat(containerStyle.paddingLeft) + parseFloat(containerStyle.paddingRight); const paddingY = parseFloat(containerStyle.paddingTop) + parseFloat(containerStyle.paddingBottom); const buttonsHeight = document.getElementById('canvasButtonContainer')?.offsetHeight || 0; const statusHeight = statusEl?.offsetHeight || 0; const maxWidth = container.clientWidth - paddingX - 2; const maxHeight = container.clientHeight - paddingY - buttonsHeight - statusHeight - 12; const aspectRatio = imgWidth / imgHeight; let newWidth = Math.min(imgWidth, maxWidth); let newHeight = newWidth / aspectRatio; if (newHeight > maxHeight) { newHeight = maxHeight; newWidth = newHeight * aspectRatio; } newWidth = Math.max(10, Math.floor(newWidth)); newHeight = Math.max(10, Math.floor(newHeight)); return { width: newWidth, height: newHeight }; }
        function getThreshold() { return parseFloat(document.getElementById('threshold').value) * 255; }
        function getBrushSize() { return parseInt(document.getElementById('brushSize').value, 10); }

        // --- Undo Functionality ---
        function saveStateForUndo(actionDescription = "action") { if (!masterImageData || isComposing || isAligning) return; try { const stateToSave = new ImageData( new Uint8ClampedArray(masterImageData.data), masterImageData.width, masterImageData.height ); historyStack.push(stateToSave); if (historyStack.length > MAX_HISTORY) { historyStack.shift(); } updateUIStates(); console.log(`Saved state for undo: ${actionDescription}`); } catch(e){ console.error("Failed to save state for undo:", e); updateStatus("Error saving undo state.", true);} }
        function undoAction() { if (historyStack.length === 0 || isComposing || isAligning) { updateStatus(isComposing || isAligning ? "Cannot undo while busy" : "Nothing to undo."); return; } const previousState = historyStack.pop(); masterImageData = previousState; displayNormalView(); updateUIStates(); updateStatus('Undo successful'); console.log("Undo action performed.");} // Use displayNormalView

        // --- Keyboard Shortcuts ---
        function setupKeyboardShortcuts() {
             document.addEventListener('keydown', (e) => {
                 if ((e.ctrlKey || e.metaKey) && e.key === 'z') { // Undo
                     e.preventDefault();
                     if (!undoButton.disabled) { undoAction(); }
                 }
                 // Manual Alignment Nudging with Arrow Keys (only if target selected)
                 if (manualTgtIndex > 0 && !isComposing && !isAligning) {
                     let dx = 0, dy = 0;
                     switch (e.key) {
                         case 'ArrowUp': dy = -1; break;
                         case 'ArrowDown': dy = 1; break;
                         case 'ArrowLeft': dx = -1; break;
                         case 'ArrowRight': dx = 1; break;
                         default: return; // Ignore other keys
                     }
                     e.preventDefault(); // Prevent page scrolling
                     nudgeManualAlign(dx, dy);
                 }
             });
        }

        // --- Image Handling ---
        async function handleImageUpload(e) {
            const files = e.target.files; if (!files.length) { updateStatus('No files selected'); return; }
            setUIBusy('loading');
            updateStatus(`Loading ${files.length} image(s)...`);
            const isFirstLoad = imageStack.images.length === 0;
            if (isFirstLoad) {
                resetApplicationState(false);
            }
            const startIndex = imageStack.images.length;

            const MAX_IMAGES = 25;
            let addedCount = 0;
            let shouldAutoCompose = false;
            let shouldAutoAlign = document.getElementById('autoAlignCheckbox').checked;

            try {
                for (let i = 0; i < Math.min(files.length, MAX_IMAGES); i++) {
                    const file = files[i];
                    updateStatus(`Loading image ${startIndex + i + 1} of ${startIndex + Math.min(files.length, MAX_IMAGES)}: ${file.name}`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                    await imageStack.addImage(file);
                    addedCount++;
                    addThumbnail(imageStack.images.length - 1);
                }

                if (imageStack.width > 0 && imageStack.height > 0) {
                    canvas.width = imageStack.width;
                    canvas.height = imageStack.height;
                    // No overlay canvas to resize
                    console.log(`Main canvas element resized to ${canvas.width}x${canvas.height}`);
                } else if (addedCount > 0) {
                    updateStatus("Warning: Could not determine image dimensions.", true);
                }

                let loadedCountMsg = `${imageStack.images.length} image${imageStack.images.length === 1 ? '' : 's'} total.`;
                if (files.length > MAX_IMAGES) { loadedCountMsg += ` (Processing limited to first ${MAX_IMAGES})`; }
                if(imageStack.width > 0) { loadedCountMsg += ` Stack size: ${imageStack.width}x${imageStack.height}.`; }
                updateStatus(loadedCountMsg);

                updateManualAlignmentOptions();

                if (imageStack.images.length === 1) {
                     const firstImageData = imageStack.images[0].imageData;
                     masterImageData = new ImageData(
                         new Uint8ClampedArray(firstImageData.data),
                         firstImageData.width,
                         firstImageData.height
                     );
                    displayNormalView(); // Display the single image
                } else if (imageStack.images.length > 1) {
                    if (masterImageData && !isFirstLoad) {
                         masterImageData = null;
                         layerMatrix = null;
                         displayNormalView(); // Clear display
                     }

                    if (shouldAutoAlign && addedCount > 0) {
                        setUIBusy('aligning');
                        await imageStack.alignStackToReference(0);
                        setUIBusy(null);
                        updateThumbnailTitlesAndIndices();
                    }
                    shouldAutoCompose = true;
                }

                if (shouldAutoCompose) {
                    console.log("Multiple images present, triggering automatic composition...");
                    updateStatus('Images loaded, starting automatic composition...');
                    await composeImages(); // This sets masterImageData and calls displayNormalView
                }

            } catch (error) {
                console.error('Error loading images:', error);
                updateStatus(`Error loading images: ${error.message || 'Unknown error'}`, true);
            } finally {
                if (!isComposing && !isAligning) {
                   setUIBusy(null);
                }
                updateUIStates();
            }
        }

        function addThumbnail(index) {
            const imgData = imageStack.images[index];
            if (!imgData || !imgData.imageData) return;

            const tempSourceCanvas = document.createElement('canvas');
             let thumbDataUrl;
             try {
                 tempSourceCanvas.width = imgData.imageData.width;
                 tempSourceCanvas.height = imgData.imageData.height;
                 const tempSourceCtx = tempSourceCanvas.getContext('2d');
                 tempSourceCtx.putImageData(imgData.imageData, 0, 0);
                 const thumbCanvas = document.createElement('canvas');
                 thumbCanvas.width = 150; thumbCanvas.height = 112;
                 const thumbCtx = thumbCanvas.getContext('2d');
                 thumbCtx.drawImage(tempSourceCanvas, 0, 0, tempSourceCanvas.width, tempSourceCanvas.height, 0, 0, 150, 112);
                 thumbDataUrl = thumbCanvas.toDataURL('image/png');
             } catch(e) {
                 console.error("Error creating thumbnail for image", index, e);
                 const thumbCanvas = document.createElement('canvas');
                 thumbCanvas.width = 150; thumbCanvas.height = 112;
                 const thumbCtx = thumbCanvas.getContext('2d');
                 thumbCtx.fillStyle = '#ddd'; thumbCtx.fillRect(0, 0, 150, 112);
                 thumbCtx.fillStyle = '#888'; thumbCtx.font = '12px Arial';
                 thumbCtx.textAlign = 'center'; thumbCtx.fillText('Error', 75, 56);
                 thumbDataUrl = thumbCanvas.toDataURL('image/png');
             }

            const thumbContainer = document.createElement('div');
            thumbContainer.className = 'thumbnail-container';
            thumbContainer.dataset.index = index;
            const thumbImg = new Image();
            thumbImg.src = thumbDataUrl;
            thumbImg.className = 'thumbnail';
            thumbImg.title = `Layer ${index}: ${imgData.originalFile.name} (${imageStack.width}x${imageStack.height})\nOffset: (${imgData.offset.x}, ${imgData.offset.y})`;
            thumbContainer.onclick = () => handleThumbnailClick(index); // Use new handler
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-thumbnail-btn';
            removeBtn.innerHTML = '×';
            removeBtn.title = 'Remove this layer';
            removeBtn.onclick = (event) => {
                event.stopPropagation();
                removeImage(parseInt(thumbContainer.dataset.index));
            };
            thumbContainer.appendChild(thumbImg);
            thumbContainer.appendChild(removeBtn);
            thumbnailStrip.appendChild(thumbContainer);
        }

        // --- New Manual Align Click Handler ---
        function handleThumbnailClick(index) {
             if (isComposing || isAligning || index < 0 || index >= imageStack.images.length) return;
             // Ignore clicks on layer 0 for alignment
             if (index === 0) {
                 updateStatus("Layer 0 is the reference and cannot be aligned.");
                 // If currently aligning, exit align mode
                 if (manualTgtIndex > 0) {
                     manualTgtIndex = -1;
                     document.getElementById('manualTgtImage').value = -1;
                     updateManualAlignmentUI();
                     displayNormalView(); // Show master image again
                 }
                 return;
             }

             // If clicking the already selected target, deselect it
             if (manualTgtIndex === index) {
                 manualTgtIndex = -1;
                 document.getElementById('manualTgtImage').value = -1; // Update dropdown
                 updateManualAlignmentUI();
                 displayNormalView(); // Show master image or grey background
             } else {
                 // Select the new target
                 manualTgtIndex = index;
                 document.getElementById('manualTgtImage').value = index; // Update dropdown
                 manualCurrentNudge = { x: 0, y: 0 }; // Reset temporary nudge
                 updateManualAlignmentUI();
                 displayManualAlignView(); // Show the alignment view
             }
         }


        function updateThumbnailTitlesAndIndices() {
             const containers = thumbnailStrip.querySelectorAll('.thumbnail-container');
             containers.forEach((container, newIndex) => {
                 container.dataset.index = newIndex;
                 const imgData = imageStack.images[newIndex];
                 if (imgData) {
                     const img = container.querySelector('.thumbnail');
                     const btn = container.querySelector('.remove-thumbnail-btn');
                     if (img) {
                         img.title = `Layer ${newIndex}: ${imgData.originalFile.name} (${imageStack.width}x${imageStack.height})\nOffset: (${imgData.offset.x}, ${imgData.offset.y})`;
                     }
                     if (btn) { btn.onclick = (event) => { event.stopPropagation(); removeImage(newIndex); }; }
                     // Only target selection class needed now
                     container.classList.toggle('selected-for-align-tgt', newIndex === manualTgtIndex);
                     container.onclick = () => handleThumbnailClick(newIndex); // Ensure handler uses new index
                 } else {
                     console.warn(`Mismatch between thumbnail and image data at index ${newIndex}`);
                     container.remove();
                 }
             });
             updateManualAlignmentOptions(); // Refresh dropdowns too
         }

        function removeImage(indexToRemove) {
            if (isComposing || isAligning) { updateStatus("Cannot remove images while busy.", true); return; }
            if (indexToRemove < 0 || indexToRemove >= imageStack.images.length) { console.error(`Invalid index to remove: ${indexToRemove}`); updateStatus("Error: Invalid image index for removal.", true); return; }

            console.log(`Removing image at index ${indexToRemove}`);
            if (masterImageData) { saveStateForUndo(`before removing image ${indexToRemove}`); }

            // If removing the image currently being aligned, exit alignment mode
            if (manualTgtIndex === indexToRemove) {
                manualTgtIndex = -1;
                manualCurrentNudge = { x: 0, y: 0 };
            } else if (manualTgtIndex > indexToRemove) {
                 manualTgtIndex--; // Adjust index if removing image below current target
            }

            const removedImage = imageStack.images.splice(indexToRemove, 1);
            if (!removedImage || removedImage.length === 0) { console.error(`Failed to splice image at index ${indexToRemove}`); return; }

            const thumbnailContainers = thumbnailStrip.querySelectorAll('.thumbnail-container');
            if (thumbnailContainers[indexToRemove]) {
                thumbnailStrip.removeChild(thumbnailContainers[indexToRemove]);
            } else {
                console.warn(`Could not find thumbnail container at index ${indexToRemove} to remove from UI.`);
            }

             // Renumber remaining thumbnails and update handlers/titles/selection
             updateThumbnailTitlesAndIndices();

            masterImageData = null; layerMatrix = null; historyStack = [];
            displayNormalView(); // Clear canvas or show remaining single image

            if (imageStack.images.length === 1) {
                 const firstImageData = imageStack.images[0].imageData;
                 masterImageData = new ImageData(new Uint8ClampedArray(firstImageData.data), firstImageData.width, firstImageData.height);
                 displayNormalView(); // Show the single remaining image
            } else if (imageStack.images.length === 0) {
                 resetApplicationState(false);
                 updateStatus("Last image removed. Upload images to begin.");
                 return;
            }

            updateStatus(`Removed image layer ${indexToRemove}. ${imageStack.images.length} images remaining.`);
            if (imageStack.images.length < 2) {
                 updateStatus(`Image removed. Need >= 2 images to align/compose. ${imageStack.images.length} images remaining.`);
            } else {
                 updateStatus(`Image removed. Re-Align or Compose if needed. ${imageStack.images.length} images remaining.`);
            }
             updateUIStates(); // Update button states etc.
        }

        // --- Composition Function ---
        async function composeImages() {
            if (imageStack.images.length < 2) { updateStatus('Need at least two images to compose'); return; }
            if (isComposing || isAligning) { updateStatus("Cannot compose: Already busy."); return; }
             // If in manual align mode, exit it first before composing
             if (manualTgtIndex > 0) {
                 manualTgtIndex = -1;
                 document.getElementById('manualTgtImage').value = -1;
                 manualCurrentNudge = { x: 0, y: 0 };
                 updateManualAlignmentUI();
                 // displayNormalView will be called by compose finishing anyway
             }

            setUIBusy('composing');
            updateStatus('Starting composition...');
            await new Promise(resolve => setTimeout(resolve, 10));
            const thresholdInternal = getThreshold();

            try {
                const { imageData, layerMatrix: lm } = await imageStack.compose(thresholdInternal);
                masterImageData = imageData;
                layerMatrix = lm;
                historyStack = [];
                displayNormalView(); // Show the final composed image
                const percentageThreshold = (thresholdInternal / 255 * 100).toFixed(0);
                updateStatus(`Composition complete. Threshold: ${percentageThreshold}%`);
            } catch (error) {
                console.error('Composition failed:', error);
                 if (error instanceof RangeError && error.message.includes("Maximum call stack size exceeded")) {
                     updateStatus(`Error: Composition failed (Stack overflow). Try fewer/smaller images.`, true);
                 } else {
                    updateStatus(`Error during composition: ${error.message || 'Unknown error'}`, true);
                 }
                masterImageData = null; layerMatrix = null;
                displayNormalView(); // Clear canvas on error
            } finally {
                setUIBusy(null);
                updateUIStates();
            }
        }

        // --- Display Functions ---

        // Renamed from displayMasterImage to clarify it shows the normal view (master or grey)
        function displayNormalView() {
             // If we are in manual align mode, do nothing here (displayManualAlignView handles it)
             if (manualTgtIndex > 0) {
                 console.log("displayNormalView called but in manual align mode, returning.");
                 return;
             }

             ctx.clearRect(0, 0, canvas.width, canvas.height);
             ctx.globalAlpha = 1.0; // Ensure alpha is reset

             if (masterImageData) {
                 // Ensure canvas size matches master image
                  if (masterImageData.width > 0 && masterImageData.height > 0 && (masterImageData.width !== canvas.width || masterImageData.height !== canvas.height)) {
                     console.warn(`Master ImageData/canvas dimension mismatch. Resizing canvas to ${masterImageData.width}x${masterImageData.height}.`);
                     canvas.width = masterImageData.width;
                     canvas.height = masterImageData.height;
                  } else if (masterImageData.width === 0 || masterImageData.height === 0){
                     console.warn("Master image data has zero dimensions, cannot display.");
                     ctx.fillStyle = '#cccccc'; // Draw grey background if data invalid
                     ctx.fillRect(0, 0, canvas.width, canvas.height);
                     return;
                  }
                 // Draw the master image
                 try {
                     ctx.putImageData(masterImageData, 0, 0);
                 } catch (e) {
                     console.error("Error using putImageData:", e);
                     updateStatus("Error displaying image.", true);
                     ctx.fillStyle = '#ffcccc'; // Error indicator
                     ctx.fillRect(0, 0, canvas.width, canvas.height);
                 }
             } else {
                 // No master image, draw default background
                 ctx.fillStyle = '#cccccc';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
             }
         }


        // --- Canvas Interaction (Lasso + Brush Click Logic - Unchanged) ---
        function handleGlobalMouseMove(e) {
            if (!drawingLasso || !masterImageData || isComposing || isAligning) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            const safeX = Math.max(0, Math.min(x, canvas.width - 1));
            const safeY = Math.max(0, Math.min(y, canvas.height - 1));
            const lastPoint = lassoPoints.length > 0 ? lassoPoints[lassoPoints.length - 1] : null;
            if (!lastPoint || Math.abs(safeX - lastPoint.x) > 1 || Math.abs(safeY - lastPoint.y) > 1) {
                 lassoPoints.push({x: safeX, y: safeY});
            }
            redrawCanvasWithLasso();
        }

        function handleGlobalMouseUp(e) {
            if (!drawingLasso || !masterImageData || isComposing || isAligning) return;
            window.removeEventListener('mousemove', handleGlobalMouseMove);
            window.removeEventListener('mouseup', handleGlobalMouseUp);
            const wasDrawingLasso = drawingLasso;
            const wasPatchLasso = isPatchLasso;
            const wasBlendLasso = isBlendLasso;
            const wasGradientLasso = isGradientLasso;
            drawingLasso = false; isPatchLasso = false; isBlendLasso = false; isGradientLasso = false;
            const modifierStillPressed = (wasPatchLasso && e.ctrlKey) || (wasBlendLasso && e.altKey) || (wasGradientLasso && e.shiftKey);
            if (!modifierStillPressed && wasDrawingLasso) {
                console.log("Modifier key released before mouse up, cancelling.");
                clearLassoAndRedraw();
                updateStatus('Lasso cancelled (modifier key released).');
                lassoPoints = [];
                return;
            }
            if (lassoPoints.length < 3) {
                console.log("Lasso too small, cancelling.");
                clearLassoAndRedraw();
                updateStatus('Lasso too small, action cancelled.');
                lassoPoints = [];
                return;
            }
            if (wasPatchLasso) { applyLassoPatch(); }
            else if (wasBlendLasso) { applyLassoBlend(); }
            else if (wasGradientLasso) { applyLassoGradient(); }
        }

        function setupCanvasEvents() {
             canvas.addEventListener('mousedown', (e) => {
                 // Allow interaction ONLY if NOT busy and NOT in manual align mode
                 if (isComposing || isAligning || manualTgtIndex > 0 || !masterImageData) {
                      if (manualTgtIndex > 0) {
                          updateStatus("In manual align mode. Use arrows to nudge, Apply/Reset buttons, or click thumbnail again to exit.");
                      } else {
                          updateStatus("Canvas interactions disabled while busy or no image loaded.");
                      }
                      return;
                 }

                 // If we reach here, we are in normal interaction mode
                 const rect = canvas.getBoundingClientRect();
                 const scaleX = canvas.width / rect.width;
                 const scaleY = canvas.height / rect.height;
                 const x = Math.floor((e.clientX - rect.left) * scaleX);
                 const y = Math.floor((e.clientY - rect.top) * scaleY);
                 const safeX = Math.max(0, Math.min(x, canvas.width - 1));
                 const safeY = Math.max(0, Math.min(y, canvas.height - 1));

                 let actionTaken = false; let actionDesc = "";

                 if (e.shiftKey) { // GRADIENT LASSO
                     if (drawingLasso) return;
                     actionTaken = true; actionDesc = "gradient overlay lasso";
                     drawingLasso = true; isPatchLasso = false; isBlendLasso = false; isGradientLasso = true;
                     lassoPoints = [{x: safeX, y: safeY}];
                     updateStatus(`Drawing gradient overlay lasso... Drag and release Shift+Mouse.`);
                 } else if (e.ctrlKey) { // PATCH LASSO
                     if (drawingLasso) return;
                     if (imageStack.images.length < 2 || !layerMatrix) { updateStatus("Patch lasso (Ctrl+Drag) requires multiple images loaded and composed."); return; }
                     actionTaken = true; actionDesc = "patch lasso";
                     drawingLasso = true; isPatchLasso = true; isBlendLasso = false; isGradientLasso = false;
                     lassoPoints = [{x: safeX, y: safeY}];
                     updateStatus(`Drawing patch lasso... Drag and release Ctrl+Mouse.`);
                 } else if (e.altKey) { // BLEND LASSO
                     if (drawingLasso) return;
                     actionTaken = true; actionDesc = "blend lasso";
                     drawingLasso = true; isPatchLasso = false; isBlendLasso = true; isGradientLasso = false;
                     lassoPoints = [{x: safeX, y: safeY}];
                     updateStatus(`Drawing blend lasso... Drag and release Alt+Mouse.`);
                 } else { // PATCH BRUSH CLICK
                     if (imageStack.images.length < 2 || !layerMatrix) { updateStatus("Patch brush click requires multiple images loaded and composed."); return; }
                     isPatchLasso = false; isBlendLasso = false; isGradientLasso = false; drawingLasso = false;
                     saveStateForUndo("patch brush click");
                     patchBrushRegion(safeX, safeY);
                     displayNormalView(); // Redraw after patch
                     return;
                 }

                 if (actionTaken && drawingLasso) {
                     saveStateForUndo(actionDesc);
                     window.addEventListener('mousemove', handleGlobalMouseMove);
                     window.addEventListener('mouseup', handleGlobalMouseUp);
                     redrawCanvasWithLasso();
                 }
             });
         }

        function patchBrushRegion(clickX, clickY) {
             if (!masterImageData || !layerMatrix || imageStack.images.length < 2) { return; }
             const w = masterImageData.width;
             const h = masterImageData.height;
             const brushDiameter = getBrushSize();
             const radius = brushDiameter / 2;
             const radiusSq = radius * radius;

             const matrixIndex = clickY * w + clickX;
             if (matrixIndex < 0 || matrixIndex >= layerMatrix.length) { updateStatus('Error: Patch click coordinates invalid.', true); return; }
             const selectedLayerIndex = layerMatrix[matrixIndex];
             if (selectedLayerIndex === undefined || selectedLayerIndex >= imageStack.images.length || !imageStack.images[selectedLayerIndex]) { updateStatus(`Error: Invalid layer data (${selectedLayerIndex}) at patch click location.`, true); return; }

             const sourceImageInfo = imageStack.images[selectedLayerIndex];
              if (!sourceImageInfo.imageData) { updateStatus(`Error: Missing image data for layer ${selectedLayerIndex}.`, true); return; }
             const sourceData = sourceImageInfo.imageData.data;
             const sourceOffset = sourceImageInfo.offset;
             const targetData = masterImageData.data;
             let pixelsPatched = 0;

             const startX = Math.max(0, Math.floor(clickX - radius));
             const endX = Math.min(w - 1, Math.ceil(clickX + radius));
             const startY = Math.max(0, Math.floor(clickY - radius));
             const endY = Math.min(h - 1, Math.ceil(clickY + radius));

             for (let currentY = startY; currentY <= endY; currentY++) {
                 for (let currentX = startX; currentX <= endX; currentX++) {
                     const dx = currentX - clickX;
                     const dy = currentY - clickY;
                     const distSq = dx * dx + dy * dy;

                     if (distSq <= radiusSq) {
                         const targetIdx = (currentY * w + currentX) * 4;
                         const sourceX = currentX - sourceOffset.x;
                         const sourceY = currentY - sourceOffset.y;

                         if (sourceX >= 0 && sourceX < w && sourceY >= 0 && sourceY < h) {
                             const sourceIdx = (sourceY * w + sourceX) * 4;
                             if (targetIdx + 3 < targetData.length && sourceIdx + 3 < sourceData.length) {
                                 targetData[targetIdx]     = sourceData[sourceIdx];
                                 targetData[targetIdx + 1] = sourceData[sourceIdx + 1];
                                 targetData[targetIdx + 2] = sourceData[sourceIdx + 2];
                                 targetData[targetIdx + 3] = sourceData[sourceIdx + 3];
                                 pixelsPatched++;
                             }
                         }
                     }
                 }
             }
             updateStatus(`Patched ${pixelsPatched} pixels in ${brushDiameter}px brush from layer ${selectedLayerIndex} at (${clickX}, ${clickY})`);
        }

        function isPointInLasso(x, y, points) {
             let inside = false;
             for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                 const xi = points[i].x, yi = points[i].y;
                 const xj = points[j].x, yj = points[j].y;
                 const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                 if (intersect) inside = !inside;
             }
             return inside;
        }

        function redrawCanvasWithLasso() { // Only called during normal interaction mode
             if (!masterImageData || manualTgtIndex > 0) return; // Don't draw lasso in align mode
             ctx.putImageData(masterImageData, 0, 0); // Redraw master first
             if (lassoPoints.length === 0 || !drawingLasso) return;

             ctx.globalAlpha = 0.6;
             ctx.beginPath();
             ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
             for (let i = 1; i < lassoPoints.length; i++) { ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y); }
             let fillStyle, strokeStyle;
             if (isPatchLasso) { fillStyle = 'rgba(0, 255, 0, 0.3)'; strokeStyle = 'rgba(0, 100, 0, 0.7)'; }
             else if (isBlendLasso) { fillStyle = 'rgba(255, 255, 0, 0.3)'; strokeStyle = 'rgba(100, 100, 0, 0.7)'; }
             else if (isGradientLasso) { fillStyle = 'rgba(255, 105, 180, 0.4)'; strokeStyle = 'rgba(255, 20, 147, 0.8)'; }
             else { fillStyle = 'rgba(150, 150, 150, 0.3)'; strokeStyle = 'rgba(50, 50, 50, 0.7)'; }
             ctx.fillStyle = fillStyle; ctx.strokeStyle = strokeStyle; ctx.lineWidth = 1;
             if (lassoPoints.length > 2) { ctx.closePath(); ctx.fill(); }
             ctx.stroke();
             if (lassoPoints.length > 0) { const lastPt = lassoPoints[lassoPoints.length - 1]; ctx.fillStyle = strokeStyle; ctx.fillRect(lastPt.x - 1, lastPt.y - 1, 3, 3); }
             ctx.globalAlpha = 1.0;
         }

        function clearLassoAndRedraw() {
            lassoPoints = [];
            displayNormalView(); // Redraw the master image or background
        }

        function applyLassoPatch() {
             if (!masterImageData || !layerMatrix || imageStack.images.length < 2 || lassoPoints.length < 3) { console.warn("Lasso patch conditions not met."); clearLassoAndRedraw(); return; }
             const w = masterImageData.width; const h = masterImageData.height;

             const startX = Math.floor(lassoPoints[0].x); const startY = Math.floor(lassoPoints[0].y);
             const startMatrixIndex = startY * w + startX;
             if (startMatrixIndex < 0 || startMatrixIndex >= layerMatrix.length) { updateStatus("Error: Invalid starting point for patch lasso.", true); console.error(`Invalid startMatrixIndex: ${startMatrixIndex}`); clearLassoAndRedraw(); return; }
             const selectedLayerIndex = layerMatrix[startMatrixIndex];
             if (selectedLayerIndex === undefined || selectedLayerIndex >= imageStack.images.length || !imageStack.images[selectedLayerIndex]) { updateStatus(`Error: Invalid layer data (${selectedLayerIndex}) at patch lasso start.`, true); console.error(`Invalid selectedLayerIndex: ${selectedLayerIndex}`); clearLassoAndRedraw(); return; }

             const sourceImageInfo = imageStack.images[selectedLayerIndex];
             if (!sourceImageInfo.imageData) { updateStatus(`Error: Missing image data for layer ${selectedLayerIndex}.`, true); clearLassoAndRedraw(); return; }
             const sourceData = sourceImageInfo.imageData.data;
             const sourceOffset = sourceImageInfo.offset;
             const targetData = masterImageData.data;

             const minX = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.x))));
             const maxX = Math.min(w - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.x))));
             const minY = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.y))));
             const maxY = Math.min(h - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.y))));

             let updatedPixels = 0;
             for (let y = minY; y <= maxY; y++) {
                 for (let x = minX; x <= maxX; x++) {
                     if (isPointInLasso(x + 0.5, y + 0.5, lassoPoints)) {
                         const targetIdx = (y * w + x) * 4;
                         const sourceX = x - sourceOffset.x;
                         const sourceY = y - sourceOffset.y;

                         if (sourceX >= 0 && sourceX < w && sourceY >= 0 && sourceY < h) {
                             const sourceIdx = (sourceY * w + sourceX) * 4;
                             if (targetIdx + 3 < targetData.length && sourceIdx + 3 < sourceData.length) {
                                 targetData[targetIdx]     = sourceData[sourceIdx];
                                 targetData[targetIdx + 1] = sourceData[sourceIdx + 1];
                                 targetData[targetIdx + 2] = sourceData[sourceIdx + 2];
                                 targetData[targetIdx + 3] = sourceData[sourceIdx + 3];
                                 updatedPixels++;
                             }
                         }
                     }
                 }
             }
             clearLassoAndRedraw();
             updateStatus(`Applied patch lasso from layer ${selectedLayerIndex} (${updatedPixels} pixels).`);
        }

        function applyLassoBlend() {
             if (!masterImageData || lassoPoints.length < 3) { console.warn("Lasso blend conditions not met."); clearLassoAndRedraw(); return; }
             const w = masterImageData.width; const h = masterImageData.height; const originalDataCopy = new Uint8ClampedArray(masterImageData.data); const targetData = masterImageData.data;
             const minX = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.x)))); const maxX = Math.min(w - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.x)))); const minY = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.y)))); const maxY = Math.min(h - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.y))));
             let updatedPixels = 0; const radius = BLEND_LASSO_RADIUS; const radiusSq = radius * radius;
             for (let y = minY; y <= maxY; y++) { for (let x = minX; x <= maxX; x++) { if (isPointInLasso(x + 0.5, y + 0.5, lassoPoints)) { let r=0,g=0,b=0,a=0,cnt=0; const cX=x; const cY=y; for(let ky=-radius;ky<=radius;ky++){ for(let kx=-radius;kx<=radius;kx++){ if(kx*kx+ky*ky>radiusSq)continue; const nx=cX+kx; const ny=cY+ky; if(nx>=0&&nx<w&&ny>=0&&ny<h){ if(isPointInLasso(nx+0.5,ny+0.5,lassoPoints)){ const idx=(ny*w+nx)*4; if(idx+3<originalDataCopy.length){r+=originalDataCopy[idx];g+=originalDataCopy[idx+1];b+=originalDataCopy[idx+2];a+=originalDataCopy[idx+3];cnt++;}}}}} if(cnt>0){ const targetIdx=(y*w+x)*4; if(targetIdx+3<targetData.length){ targetData[targetIdx]=Math.round(r/cnt);targetData[targetIdx+1]=Math.round(g/cnt);targetData[targetIdx+2]=Math.round(b/cnt);targetData[targetIdx+3]=Math.round(a/cnt);updatedPixels++;}}}}}
             clearLassoAndRedraw(); updateStatus(`Applied blend/feather effect (${updatedPixels} pixels inside lasso).`);
        }

        function applyLassoGradient() {
             if (!masterImageData || lassoPoints.length < 3) { console.warn("Lasso gradient conditions not met."); clearLassoAndRedraw(); return; } console.log("Starting applyLassoGradient (Overlay Mode)...");
             const w = masterImageData.width; const h = masterImageData.height; const originalData = new Uint8ClampedArray(masterImageData.data); const targetData = masterImageData.data; const minX = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.x)))); const maxX = Math.min(w - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.x)))); const minY = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.y)))); const maxY = Math.min(h - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.y)))); const gradWidth = maxX - minX; const gradHeight = maxY - minY; const isHorizontal = gradWidth >= gradHeight; const len = isHorizontal ? gradWidth : gradHeight; console.log(`Gradient direction: ${isHorizontal ? 'Horizontal' : 'Vertical'}, Length: ${len}`); const sampleW = Math.max(1, Math.floor(Math.min(gradWidth, gradHeight) * 0.1)); let sR=0,sG=0,sB=0,sA=0,sCnt=0; let eR=0,eG=0,eB=0,eA=0,eCnt=0;
             for (let y = minY; y <= maxY; y++) { for (let x = minX; x <= maxX; x++) { if (isPointInLasso(x + 0.5, y + 0.5, lassoPoints)) { const idx = (y * w + x) * 4; if (idx + 3 >= originalData.length) continue; const cR=originalData[idx],cG=originalData[idx+1],cB=originalData[idx+2],cA=originalData[idx+3]; if(isHorizontal){if(x<minX+sampleW){sR+=cR;sG+=cG;sB+=cB;sA+=cA;sCnt++;}else if(x>maxX-sampleW){eR+=cR;eG+=cG;eB+=cB;eA+=cA;eCnt++;}}else{if(y<minY+sampleW){sR+=cR;sG+=cG;sB+=cB;sA+=cA;sCnt++;}else if(y>maxY-sampleW){eR+=cR;eG+=cG;eB+=cB;eA+=cA;eCnt++;}}}}}
             const c1={r:sCnt>0?sR/sCnt:128,g:sCnt>0?sG/sCnt:128,b:sCnt>0?sB/sCnt:128,a:sCnt>0?sA/sCnt:255}; const c2={r:eCnt>0?eR/eCnt:128,g:eCnt>0?eG/eCnt:128,b:eCnt>0?eB/eCnt:128,a:eCnt>0?eA/eCnt:255}; if(sCnt===0||eCnt===0){console.warn("Could not sample start/end colors.");updateStatus("Warning: Could not sample gradient colors.");}else{console.log(`Start Color: R=${c1.r.toFixed(0)} G=${c1.g.toFixed(0)} B=${c1.b.toFixed(0)}`);console.log(`End Color: R=${c2.r.toFixed(0)} G=${c2.g.toFixed(0)} B=${c2.b.toFixed(0)}`);}
             let updatedPixels = 0; const op = GRADIENT_LASSO_OPACITY; const invOp = 1 - op;
             for (let y = minY; y <= maxY; y++) { for (let x = minX; x <= maxX; x++) { if (isPointInLasso(x + 0.5, y + 0.5, lassoPoints)) { let t = 0; if (len > 0) { t = isHorizontal ? (x - minX) / len : (y - minY) / len; t = Math.max(0, Math.min(1, t)); } const gradR = c1.r*(1-t)+c2.r*t; const gradG = c1.g*(1-t)+c2.g*t; const gradB = c1.b*(1-t)+c2.b*t; const idx = (y * w + x) * 4; if (idx + 3 < targetData.length) { const oR=originalData[idx],oG=originalData[idx+1],oB=originalData[idx+2],oA=originalData[idx+3]; targetData[idx]=Math.round(oR*invOp+gradR*op); targetData[idx+1]=Math.round(oG*invOp+gradG*op); targetData[idx+2]=Math.round(oB*invOp+gradB*op); targetData[idx+3]=oA; updatedPixels++; }}}}
             console.log(`Gradient overlay applied. Updated pixels: ${updatedPixels}`); clearLassoAndRedraw(); updateStatus(`Applied gradient overlay effect (${updatedPixels} pixels at ${op*100}% opacity).`);
        }

        // --- Alignment Specific Functions ---
        async function runAutoAlignment() {
             if (imageStack.images.length < 2 || isComposing || isAligning) {
                 updateStatus(isComposing || isAligning ? "Busy." : "Need at least 2 images to align.");
                 return;
             }
             // Exit manual align mode if active
             if (manualTgtIndex > 0) {
                 manualTgtIndex = -1;
                 document.getElementById('manualTgtImage').value = -1;
                 updateManualAlignmentUI();
             }
             setUIBusy('aligning');
             try {
                 await imageStack.alignStackToReference(0);
                 updateThumbnailTitlesAndIndices();
                 masterImageData = null; layerMatrix = null;
                 displayNormalView(); // Clear display
                 updateStatus("Auto-alignment finished. Click Compose! to see results.");
             } catch (error) {
                 console.error("Auto Alignment failed:", error);
                 updateStatus("Error during auto-alignment.", true);
             } finally {
                 setUIBusy(null);
                 updateUIStates();
             }
         }

         function resetAllOffsets() {
              if (imageStack.images.length === 0 || isComposing || isAligning) return;
              // Exit manual align mode if active
               if (manualTgtIndex > 0) {
                   manualTgtIndex = -1;
                   document.getElementById('manualTgtImage').value = -1;
               }
              saveStateForUndo("before reset all offsets");
              imageStack.resetAllOffsets();
              updateThumbnailTitlesAndIndices();
              masterImageData = null; layerMatrix = null;
              displayNormalView(); // Clear display
              updateStatus("All alignment offsets reset. Re-compose required.");
              manualCurrentNudge = {x:0, y:0};
              updateManualAlignmentOptions();
              updateManualAlignmentUI();
              updateUIStates();
         }

         function setupAlignmentControls() {
             // Removed Ref dropdown setup
             const tgtSelect = document.getElementById('manualTgtImage');

             tgtSelect.addEventListener('change', () => {
                   const newTgtIndex = parseInt(tgtSelect.value, 10);
                   // Cannot select layer 0 or invalid index
                    if (newTgtIndex <= 0) {
                         if (manualTgtIndex > 0) { // If deselecting via dropdown
                             manualTgtIndex = -1;
                             updateManualAlignmentUI();
                             displayNormalView();
                         }
                        return;
                    }
                    // If selecting a valid target different from current
                   if (newTgtIndex !== manualTgtIndex) {
                       manualTgtIndex = newTgtIndex;
                       manualCurrentNudge = { x: 0, y: 0 };
                       updateManualAlignmentUI();
                       displayManualAlignView();
                   }
             });
              updateManualAlignmentOptions(); // Initial population
         }

         // Updated to remove reference dropdown logic
         function updateManualAlignmentOptions() {
             // Removed refSelect
             const tgtSelect = document.getElementById('manualTgtImage');
             const numImages = imageStack.images.length;

             const currentTgtVal = tgtSelect.value;

             // Removed refSelect clearing
             tgtSelect.innerHTML = '<option value="-1">Align Image...</option>'; // Changed default text

             for (let i = 0; i < numImages; i++) {
                 // Ref dropdown population removed
                 // Only populate target dropdown for layers > 0
                 if (i > 0) {
                     const name = imageStack.images[i]?.originalFile?.name || `Image ${i}`;
                     const shortName = name.length > 20 ? name.substring(0, 17) + '...' : name;
                     const optionText = `[${i}] ${shortName}`;
                     tgtSelect.innerHTML += `<option value="${i}">${optionText}</option>`;
                 }
             }

             // Restore selections if still valid
             // Removed refSelect restoration
             tgtSelect.value = (parseInt(currentTgtVal) < numImages && parseInt(currentTgtVal) > 0) ? currentTgtVal : "-1";

             // Update internal index based on restored value
             // Removed manualRefIndex update
             manualTgtIndex = parseInt(tgtSelect.value, 10);

             // Ensure target index is valid
             if (manualTgtIndex <= 0 || manualTgtIndex >= numImages) manualTgtIndex = -1;

             // Don't call updateManualAlignmentUI here, let the caller handle it
         }

         // Updated to remove reference logic
         function updateManualAlignmentUI() {
             // Removed refSelect
             const tgtSelect = document.getElementById('manualTgtImage');
             const nudgeButtons = document.querySelectorAll('.manual-nudge-button');
             const applyButton = document.getElementById('manualApplyOffset');
             const resetButton = document.getElementById('manualResetOffset');
             const statusSpan = document.getElementById('manualAlignStatus');
             const containers = thumbnailStrip.querySelectorAll('.thumbnail-container');

             const hasImages = imageStack.images.length > 0;
             const canSelect = hasImages && !isComposing && !isAligning;
              // Manual align possible if Tgt selected (>0) and not busy
             const canManualAlign = manualTgtIndex > 0 && canSelect;

             // Removed refSelect disable logic
             tgtSelect.disabled = !canSelect;
             nudgeButtons.forEach(btn => btn.disabled = !canManualAlign);
             applyButton.disabled = !canManualAlign;
             resetButton.disabled = !canManualAlign;

             if (canManualAlign) {
                 const currentOffset = imageStack.getOffset(manualTgtIndex);
                 const totalOffsetX = currentOffset.x + manualCurrentNudge.x;
                 const totalOffsetY = currentOffset.y + manualCurrentNudge.y;
                 statusSpan.textContent = `Nudge Target ${manualTgtIndex}: (${manualCurrentNudge.x}, ${manualCurrentNudge.y}) Total: (${totalOffsetX}, ${totalOffsetY})`;
             } else {
                 if (!hasImages) statusSpan.textContent = "No images";
                 else if (manualTgtIndex === -1) statusSpan.textContent = "Select Image (>0) to Align";
                 else statusSpan.textContent = "Ready"; // Should not happen if tgt is selected
             }

              // Update thumbnail borders (only target now)
             containers.forEach((container, index) => {
                 // Removed ref selection class toggle
                 container.classList.toggle('selected-for-align-tgt', index === manualTgtIndex);
             });
         }

        // --- New function to draw the specific manual alignment view ---
        function displayManualAlignView() {
            const targetIndex = manualTgtIndex;
            const referenceIndex = targetIndex - 1; // Image below is the reference

            if (targetIndex <= 0 || referenceIndex < 0 || // Basic index checks
                targetIndex >= imageStack.images.length || referenceIndex >= imageStack.images.length || // Bounds checks
                !imageStack.images[targetIndex]?.imageData || !imageStack.images[referenceIndex]?.imageData) // Data checks
            {
                console.warn("Cannot display manual align view: Invalid indices or missing image data.", targetIndex, referenceIndex);
                displayNormalView(); // Fallback to normal view
                return;
            }

            const refImgData = imageStack.images[referenceIndex].imageData;
            const tgtImgData = imageStack.images[targetIndex].imageData;
            const refOffset = imageStack.getOffset(referenceIndex); // Get reference's stored offset
            const tgtBaseOffset = imageStack.getOffset(targetIndex); // Get target's stored offset
            // Calculate current display position for target including nudge
            const tgtDisplayX = tgtBaseOffset.x + manualCurrentNudge.x;
            const tgtDisplayY = tgtBaseOffset.y + manualCurrentNudge.y;

            // Ensure canvas size is correct
            if (canvas.width !== imageStack.width || canvas.height !== imageStack.height) {
                canvas.width = imageStack.width;
                canvas.height = imageStack.height;
            }

            // 1. Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0; // Reset alpha

            // 2. Draw Reference Image (image i-1) - Opaque at its *stored* offset
            const refCanvas = createImageBitmapFromImageData(refImgData);
            if (refCanvas) {
                 ctx.drawImage(refCanvas, refOffset.x, refOffset.y);
            } else {
                 console.error("Failed to create canvas for reference image", referenceIndex);
                 ctx.fillStyle = '#aa0000'; // Error indicator
                 ctx.fillRect(refOffset.x, refOffset.y, 50, 50); // Draw placeholder
            }


            // 3. Draw Target Image (image i) - Transparent at its *current display* offset (base + nudge)
            const tgtCanvas = createImageBitmapFromImageData(tgtImgData);
            if(tgtCanvas) {
                ctx.globalAlpha = MANUAL_ALIGN_VIEW_OPACITY; // Set transparency
                ctx.drawImage(tgtCanvas, tgtDisplayX, tgtDisplayY);
                ctx.globalAlpha = 1.0; // Reset alpha
            } else {
                 console.error("Failed to create canvas for target image", targetIndex);
                  ctx.globalAlpha = MANUAL_ALIGN_VIEW_OPACITY;
                  ctx.fillStyle = '#0000aa'; // Error indicator
                  ctx.fillRect(tgtDisplayX, tgtDisplayY, 50, 50); // Draw placeholder
                  ctx.globalAlpha = 1.0;
             }
            updateStatus(`Aligning Layer ${targetIndex} (Transparent) to Layer ${referenceIndex} (Opaque). Use arrows/buttons.`);
        }


        // Removed clearManualAlignOverlay - replaced by displayNormalView or displayManualAlignView calls

        // Helper to draw ImageData via temp canvas
        function createImageBitmapFromImageData(imageData) {
               if (!imageData || !imageData.width || !imageData.height || !imageData.data) {
                   console.error("Invalid imageData passed to createImageBitmapFromImageData");
                   return null;
               }
              const tempCanvas = document.createElement('canvas');
              try {
                  tempCanvas.width = imageData.width;
                  tempCanvas.height = imageData.height;
                  const tempCtx = tempCanvas.getContext('2d');
                  tempCtx.putImageData(imageData, 0, 0);
                  return tempCanvas; // Returns canvas element
              } catch (e) {
                   console.error("Error putting imageData on temp canvas:", e);
                   return null;
              }
         }

        // Nudge function updates nudge and redraws alignment view
        function nudgeManualAlign(dx, dy) {
            if (manualTgtIndex <= 0 || isComposing || isAligning) return; // Check if in align mode
            manualCurrentNudge.x += dx;
            manualCurrentNudge.y += dy;
            updateManualAlignmentUI(); // Update status text first
            displayManualAlignView(); // Redraw the alignment view immediately
        }

        // Apply function saves nudge to permanent offset and exits align mode
        function applyManualOffset() {
            if (manualTgtIndex <= 0 || isComposing || isAligning) return;
            const baseOffset = imageStack.getOffset(manualTgtIndex);
            const newOffset = {
                x: baseOffset.x + manualCurrentNudge.x,
                y: baseOffset.y + manualCurrentNudge.y
            };
            saveStateForUndo(`apply manual offset to layer ${manualTgtIndex}`);
            imageStack.setOffset(manualTgtIndex, newOffset); // Use setter for rounding
            const appliedNudgeX = manualCurrentNudge.x; // Store before resetting
            const appliedNudgeY = manualCurrentNudge.y;
            manualCurrentNudge = { x: 0, y: 0 }; // Reset temporary nudge

            updateThumbnailTitlesAndIndices(); // Update title in thumbnail
            updateStatus(`Applied nudge (${appliedNudgeX}, ${appliedNudgeY}) to layer ${manualTgtIndex}. New offset: (${newOffset.x}, ${newOffset.y}). Re-compose needed.`);

            // Exit alignment mode
            manualTgtIndex = -1;
            document.getElementById('manualTgtImage').value = -1;
            updateManualAlignmentUI(); // Update buttons and status
            displayNormalView(); // Show master image or grey

            masterImageData = null; // Invalidate master image as offsets changed
            layerMatrix = null;
            updateUIStates(); // General UI update (e.g., enable Compose)
        }

        // Reset function sets permanent offset to 0 and exits align mode
        function resetCurrentManualOffset() {
            if (manualTgtIndex <= 0 || isComposing || isAligning) return;
            saveStateForUndo(`reset manual offset for layer ${manualTgtIndex}`);
            imageStack.setOffset(manualTgtIndex, { x: 0, y: 0 }); // Reset stored offset
            manualCurrentNudge = { x: 0, y: 0 }; // Reset temporary nudge

            updateThumbnailTitlesAndIndices();
            updateStatus(`Reset offset for layer ${manualTgtIndex}. Re-compose needed.`);

             // Exit alignment mode
             manualTgtIndex = -1;
             document.getElementById('manualTgtImage').value = -1;
             updateManualAlignmentUI();
             displayNormalView(); // Show master or grey

            masterImageData = null; // Invalidate master image
            layerMatrix = null;
            updateUIStates();
        }

        // --- Utility and Reset Functions ---
        function setTracyRosePreset() {
            if (isComposing || isAligning) return;
            const slider = document.getElementById('threshold');
            const valueDisplay = document.getElementById('threshold-value');
            if (slider && valueDisplay) {
                slider.value = 0.13;
                const percentage = (parseFloat(slider.value) * 100).toFixed(0);
                valueDisplay.textContent = percentage + '%';
            }
            updateStatus('Tracy Rose preset applied (Threshold ~13%). Click Compose to apply.');
            console.log('Tracy Rose preset applied');
        }

        function resetApplicationState(clearFileInput = true) {
            console.log("Resetting application state...");
            imageStack = new ImageStack(); masterImageData = null; layerMatrix = null;
            lassoPoints = []; drawingLasso = false; isPatchLasso = false; isBlendLasso = false; isGradientLasso = false;
            historyStack = []; isComposing = false; isAligning = false;

            // Reset manual alignment state
             manualTgtIndex = -1; manualCurrentNudge = { x: 0, y: 0 };

            if (ctx && canvas) { ctx.clearRect(0, 0, canvas.width, canvas.height); canvas.width = 300; canvas.height = 150; ctx.fillStyle = '#cccccc'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
            // No overlay canvas to clear

            if (clearFileInput && document.getElementById('imageInput')) { document.getElementById('imageInput').value = ''; }
            if (thumbnailStrip) thumbnailStrip.innerHTML = '';

            const thresholdSlider = document.getElementById('threshold'); const thresholdValueDisplay = document.getElementById('threshold-value');
            if (thresholdSlider) thresholdSlider.value = 0.15;
            if (thresholdValueDisplay) { const percentage = (parseFloat(thresholdSlider.value) * 100).toFixed(0); thresholdValueDisplay.textContent = percentage + '%'; }
            const brushSizeSlider = document.getElementById('brushSize'); const brushSizeValueDisplay = document.getElementById('brushSize-value');
            if (brushSizeSlider) brushSizeSlider.value = 100;
            if (brushSizeValueDisplay) brushSizeValueDisplay.textContent = brushSizeSlider.value + 'px';

             document.getElementById('autoAlignCheckbox').checked = true;
             updateManualAlignmentOptions();
             updateManualAlignmentUI();

            setUIBusy(null);
            updateUIStates();
        }
        function resetApplication() { resetApplicationState(true); updateStatus('Application reset. Upload images to begin.'); }

        function saveImage() {
            if (!masterImageData) { updateStatus('No image to save', true); return; }
            if (isComposing || isAligning || manualTgtIndex > 0) { updateStatus("Cannot save while busy or aligning.", true); return; } // Also check align mode
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = masterImageData.width;
            tempCanvas.height = masterImageData.height;
            const tempCtx = tempCanvas.getContext('2d');
            try {
                tempCtx.putImageData(masterImageData, 0, 0);
                const dataURL = tempCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'Aquiplicity_Aligned_Master.png';
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                updateStatus(`Master image saved as ${link.download} (${masterImageData.width}x${masterImageData.height})`);
                console.log('Image saved');
            } catch (error) {
                console.error("Error saving image:", error);
                 let errorMsg = "Error saving image.";
                 if (error instanceof DOMException && error.name === 'SecurityError') {
                    errorMsg = "Error saving: Canvas may be tainted by cross-origin image data.";
                 } else if (error instanceof RangeError) {
                     errorMsg = "Error saving: Image may be too large for data URL.";
                 } else {
                     errorMsg = `Error saving image: ${error.message || 'Unknown error'}`;
                 }
                updateStatus(errorMsg, true);
            }
        }

    </script>
</body>
</html>