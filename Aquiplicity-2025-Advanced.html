<!DOCTYPE html>
<html>
<head>
    <title>Aquiplicity 2025 JavaScript (Single Threshold - Original Resolution)</title>
    <style>
        /* CSS Styles (Unchanged) */
        body {
            margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; font-family: Arial, sans-serif; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
        }
        #marqueeContainer { position: fixed; top: 0; left: 0; width: 100%; background: #f0f0f0; border-bottom: 1px solid #ccc; overflow: hidden; height: 20px; z-index: 1000; }
        #marquee { font-size: 12px; white-space: nowrap; animation: scroll 30s linear infinite; display: inline-block; padding-left: 100%; }
        @keyframes scroll { 0% { transform: translateX(0%); } 100% { transform: translateX(-200%); } }
        #controls { display: flex; align-items: center; padding: 10px; flex-wrap: wrap; margin-top: 20px; background: #f8f8f8; border-bottom: 1px solid #ccc; }
        #mainContainer { display: flex; flex: 1; overflow: hidden; }
        #thumbnailStrip { display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; padding: 5px; border-right: 1px solid #ccc; background: #f0f0f0; width: 165px; flex-shrink: 0; }
        .thumbnail { width: 150px; height: 112px; object-fit: cover; margin-bottom: 5px; border: 1px solid #999; cursor: pointer; background-color: #fff; }
        .thumbnail:hover { border-color: #000; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        #workingArea {
            flex: 1; display: flex; flex-direction: column; align-items: center;
            overflow-y: auto; overflow-x: hidden; /* Keep scrollbar fix */
            padding: 10px; background: #e9e9e9;
        }
        canvas {
            border: 1px solid black;
            background-color: white;
            max-width: 100%; /* Don't exceed container width */
            max-height: calc(100% - 60px); /* Don't exceed container height (minus buttons/status) */
            display: block;
            object-fit: contain; /* Scale down visually while maintaining aspect ratio */
            cursor: crosshair;
            box-sizing: border-box; /* Include border in size calculations */
        }
        #status { margin: 5px; font-size: 14px; text-align: center; flex-shrink: 0; min-height: 1.2em; color: #333; width: 100%; }
        button, input[type="file"]::file-selector-button { margin: 5px; padding: 5px 10px; font-size: 12px; border-radius: 3px; cursor: pointer; transition: background-color 0.2s ease, box-shadow 0.1s ease; }
        input[type="file"]::file-selector-button { border: 1px solid #ccc; background-color: #f0f0f0; }
        input[type="file"]::file-selector-button:hover { background-color: #e0e0e0; }
        .slider-container { margin: 0 10px; display: flex; align-items: center; }
        .slider-label { margin-right: 5px; font-size: 12px; }
        input[type="range"] { width: 80px; height: 5px; cursor: pointer; }
        .slider-value { margin-left: 5px; min-width: 25px; font-size: 12px; text-align: right; }
        .tracy-rose-button, .reset-button, .action-button { color: white; padding: 4px 8px; border: none; box-shadow: 0 2px 2px rgba(0,0,0,0.2); font-family: Arial, sans-serif; font-size: 12px; transition: all 0.1s; margin: 0 5px; }
        .tracy-rose-button:active, .reset-button:active, .action-button:active { box-shadow: 0 1px 1px rgba(0,0,0,0.2); transform: translateY(1px); }
        .tracy-rose-button:disabled, .reset-button:disabled, .action-button:disabled { background-color: #cccccc !important; color: #666666; cursor: not-allowed; box-shadow: none; transform: none; }
        .tracy-rose-button { background-color: #0066cc; } .tracy-rose-button:hover:not(:disabled) { background-color: #0077e6; }
        .reset-button { background-color: #cc0000; } .reset-button:hover:not(:disabled) { background-color: #e60000; }
        .action-button { background-color: #5cb85c; } .action-button:hover:not(:disabled) { background-color: #6cd96c; }
        #canvasButtonContainer { display: flex; justify-content: center; margin-top: 10px; flex-shrink: 0; width: 100%; }
    </style>
</head>
<body>
    <!-- Updated Marquee -->
    <div id="marqueeContainer"><div id="marquee">Images auto-composed on load. Adjust Threshold & click Compose! to re-run. Patch/Blend/Undo available.</div></div>
    <div id="controls">
        <input type="file" id="imageInput" multiple accept="image/*">
        <button id="composeButton" class="action-button" onclick="composeImages()" disabled>Compose!</button>
        <button id="undoButton" class="action-button" onclick="undoAction()" disabled>Undo</button>
        <button class="reset-button" onclick="resetApplication()">Reset</button>
        <!-- Only one threshold slider -->
        <div class="slider-container">
            <span class="slider-label">Threshold:</span>
            <input type="range" id="threshold" min="0.01" max="1.0" step="0.01" value="0.05">
            <span class="slider-value" id="threshold-value">0.05</span>
        </div>
        <!-- Removed T2 and T3 sliders -->
        <button class="tracy-rose-button" onclick="setTracyRosePreset()">By Tracy Rose</button>
    </div>
    <div id="mainContainer">
        <div id="thumbnailStrip"></div>
        <div id="workingArea">
            <canvas id="canvasOutput"></canvas>
            <div id="canvasButtonContainer"><button id="saveButton" class="action-button" onclick="saveImage()" disabled>Save Master Image</button></div>
            <div id="status">Upload images to begin</div>
        </div>
    </div>

    <script type="text/javascript">
        class ImageStack { // --- ImageStack Class ---
            constructor() { this.images = []; this.width = 0; this.height = 0; }

            // --- addImage (Unchanged) ---
            async addImage(file) { /* ... same as previous step ... */ const img = new Image(); const objectUrl = URL.createObjectURL(file); try { await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = (err) => reject(new Error(`Image load failed: ${file.name} - ${err.type || 'Unknown error'}`)); img.src = objectUrl; }); const canvas = document.createElement("canvas"); const ctx = canvas.getContext("2d", { willReadFrequently: true }); if (this.images.length === 0) { canvas.width = img.width; canvas.height = img.height; this.width = img.width; this.height = img.height; console.log(`Setting stack dimensions to ${this.width}x${this.height} based on first image: ${file.name}`); if (this.width > 4000 || this.height > 4000) { console.warn(`Warning: Processing large image resolution (${this.width}x${this.height}). This may be slow and use significant memory.`); updateStatus(`Warning: Large resolution (${this.width}x${this.height}). Processing may be slow.`); } } else { if (img.width !== this.width || img.height !== this.height) { console.log(`Resizing image ${file.name} (${img.width}x${img.height}) to match stack dimensions (${this.width}x${this.height})`); } canvas.width = this.width; canvas.height = this.height; } ctx.drawImage(img, 0, 0, canvas.width, canvas.height); const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); for (let i = 3; i < imageData.data.length; i += 4) { imageData.data[i] = 255; } this.images.push(imageData); console.log(`Added image ${file.name} (${imageData.width}x${imageData.height}) to stack. Total: ${this.images.length}`); } finally { URL.revokeObjectURL(objectUrl); } }
            // --- smoothLayer (Unchanged) ---
            smoothLayer(imageData, iterations = 6) { /* ... same ... */ if (!imageData) return null; const data = new Float32Array(imageData.data); const temp = new Float32Array(data.length); const width = imageData.width; const height = imageData.height; for (let iter = 0; iter < iterations; iter++) { for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const idx = (y * width + x) * 4; if (x === 0 || x === width - 1 || y === 0 || y === height - 1) { for (let c = 0; c < 4; c++) { temp[idx + c] = data[idx + c]; } } else { for (let c = 0; c < 3; c++) { temp[idx + c] = ( data[((y - 1) * width + x) * 4 + c] + data[((y + 1) * width + x) * 4 + c] + data[(y * width + (x - 1)) * 4 + c] + data[(y * width + (x + 1)) * 4 + c] ) / 4; } temp[idx + 3] = data[idx + 3]; } } } data.set(temp); } const result = new Uint8ClampedArray(data.length); for (let i = 0; i < data.length; i++) { result[i] = Math.round(Math.min(255, Math.max(0, data[i]))); } return new ImageData(result, width, height); }
            // --- colorDistance (Unchanged) ---
            colorDistance(r1, g1, b1, r2, g2, b2) { /* ... same ... */ const dr = r1 - r2; const dg = g1 - g2; const db = b1 - b2; return Math.sqrt(dr * dr + dg * dg + db * db); }

            // --- MODIFIED compose Function ---
            async compose(threshold) { // Takes a single threshold value
                if (this.images.length < 2) { throw new Error("Need at least two images"); }
                console.log("Starting composition with", this.images.length, "images and threshold:", threshold);
                console.log(`Composition dimensions: ${this.width}x${this.height}`);

                updateStatus("Smoothing layers...");
                await new Promise(resolve => setTimeout(resolve, 10));

                // Smooth all layers (same as before)
                const smoothedLayers = [];
                for (let i = 0; i < this.images.length; i++) {
                     updateStatus(`Smoothing layer ${i+1} of ${this.images.length}...`);
                     await new Promise(resolve => setTimeout(resolve, 0));
                     smoothedLayers.push(this.smoothLayer(this.images[i]));
                     if (!smoothedLayers[i]) { throw new Error(`Smoothing failed for layer ${i}`); }
                }
                console.log(`${smoothedLayers.length} layers smoothed.`);

                // --- CHANGE: Create only ONE master image buffer ---
                const masterImageData = new Uint8ClampedArray(this.width * this.height * 4);
                const layerMatrix = new Uint8Array(this.width * this.height); // Still useful for patching

                updateStatus("Processing pixels...");
                await new Promise(resolve => setTimeout(resolve, 10));
                console.log("Processing pixels...");

                const w = this.width;
                const h = this.height;
                const totalPixels = w * h;
                let processedPixels = 0;
                const reportInterval = Math.max(10, Math.floor(h / 20));

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const idx = (y * w + x) * 4;

                        // Get smoothed base layer pixel
                        const baseR_s = smoothedLayers[0].data[idx];
                        const baseG_s = smoothedLayers[0].data[idx + 1];
                        const baseB_s = smoothedLayers[0].data[idx + 2];

                        // --- CHANGE: Logic applied only ONCE per pixel ---
                        let bestLayerIndex = this.images.length - 1; // Default to TOP layer
                        let bestDistFound = 0;  // Track best distance found

                        // Iterate from top layer down to layer 1
                        for (let layerIdx = this.images.length - 1; layerIdx >= 1; layerIdx--) {
                            const currentPixelData_s = smoothedLayers[layerIdx].data;
                            const currentR_s = currentPixelData_s[idx];
                            const currentG_s = currentPixelData_s[idx + 1];
                            const currentB_s = currentPixelData_s[idx + 2];

                            const dist = this.colorDistance(currentR_s, currentG_s, currentB_s, baseR_s, baseG_s, baseB_s);

                            // If distance exceeds threshold AND is better than the best distance found so far
                            if (dist > threshold && dist > bestDistFound) {
                                bestDistFound = dist;
                                bestLayerIndex = layerIdx; // This layer is currently the best candidate
                            }
                        }
                        // After checking all layers, use the pixel from the *original* best layer
                        const sourceImageData = this.images[bestLayerIndex].data;
                        masterImageData[idx]     = sourceImageData[idx];
                        masterImageData[idx + 1] = sourceImageData[idx + 1];
                        masterImageData[idx + 2] = sourceImageData[idx + 2];
                        masterImageData[idx + 3] = sourceImageData[idx + 3]; // Use original alpha

                        // Store the chosen layer index
                        layerMatrix[y * w + x] = bestLayerIndex;
                        // --- END CHANGE for single pixel ---

                        processedPixels++;
                    }
                     // Progress update
                     if (y % reportInterval === 0 && y > 0) {
                          const progress = Math.round((processedPixels / totalPixels) * 100);
                          updateStatus(`Processing pixels... (${progress}%)`);
                          await new Promise(resolve => setTimeout(resolve, 0));
                     }
                }

                // --- CHANGE: Remove combining/averaging step ---
                // updateStatus("Combining threshold results..."); // No longer needed
                // console.log("Combining threshold results..."); // No longer needed
                // Averaging loop removed

                console.log("Composition completed.");
                // Return the single calculated master image
                return {
                    imageData: new ImageData(masterImageData, w, h),
                    layerMatrix
                };
            }
            // --- END MODIFIED COMPOSE ---
        }

        // --- Global Variables ---
        const PATCH_SIZE = 2; const MAX_HISTORY = 15;
        let canvas, ctx;
        let imageStack = new ImageStack();
        let statusEl, composeButton, thumbnailStrip, undoButton, saveButton;
        let masterImageData = null; let layerMatrix = null;
        let lassoPoints = []; let drawingLasso = false; let isPatchLasso = false;
        let historyStack = []; let isComposing = false;

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('canvasOutput');
            ctx = canvas.getContext('2d', { willReadFrequently: true });
            statusEl = document.getElementById('status');
            composeButton = document.getElementById('composeButton');
            thumbnailStrip = document.getElementById('thumbnailStrip');
            undoButton = document.getElementById('undoButton');
            saveButton = document.getElementById('saveButton');
            if (!canvas || !ctx || !composeButton) {
                updateStatus('Error: Core UI elements failed to load!', true); return;
            }
            document.getElementById('imageInput').addEventListener('change', handleImageUpload);
            setupCanvasEvents();
            setupKeyboardShortcuts();

            // --- CHANGE: Setup only one slider ---
            const slider = document.getElementById('threshold');
            const valueDisplay = document.getElementById('threshold-value');
            if (slider && valueDisplay) {
                slider.addEventListener('input', () => { valueDisplay.textContent = parseFloat(slider.value).toFixed(2); });
                valueDisplay.textContent = parseFloat(slider.value).toFixed(2); // Set initial display
            }
            // --- END CHANGE ---

            updateUndoButtonState();
            updateSaveButtonState();
            updateComposeButtonState();
            console.log('Aquiplicity 2025 Initialized (Single Threshold, Original Resolution Mode)');
        });

        // --- UI Update Functions (Unchanged except setUIBusy) ---
        function updateStatus(message, isError = false) { /* ... same ... */ if (statusEl) { statusEl.textContent = message; statusEl.style.color = isError ? 'red' : '#333'; } if (isError) { console.error("Status:", message); } else { console.log("Status:", message); } }
        function updateUndoButtonState() { /* ... same ... */ if (undoButton) undoButton.disabled = historyStack.length === 0 || isComposing; }
        function updateSaveButtonState() { /* ... same ... */ if (saveButton) saveButton.disabled = masterImageData === null || isComposing; }
        function updateComposeButtonState() { /* ... same ... */ if (composeButton) composeButton.disabled = imageStack.images.length < 2 || isComposing; }
        function setUIBusy(busy) {
            isComposing = busy;
            updateComposeButtonState();
            updateUndoButtonState();
            updateSaveButtonState();
            document.body.style.cursor = busy ? 'wait' : 'default';
            // --- CHANGE: Disable only one slider ---
            const slider = document.getElementById('threshold');
            if(slider) slider.disabled = busy;
            // --- END CHANGE ---
            if(document.getElementById('imageInput')) document.getElementById('imageInput').disabled = busy;
            if(document.querySelector('.reset-button')) document.querySelector('.reset-button').disabled = busy;
            if(document.querySelector('.tracy-rose-button')) document.querySelector('.tracy-rose-button').disabled = busy;
         }

        // --- Core Logic Functions ---
        // --- fitToScreen (Unchanged, still unused by addImage) ---
        function fitToScreen(imgWidth, imgHeight) { /* ... same ... */ const container = document.getElementById('workingArea'); if (!container) return { width: imgWidth, height: imgHeight }; const containerStyle = window.getComputedStyle(container); const paddingX = parseFloat(containerStyle.paddingLeft) + parseFloat(containerStyle.paddingRight); const paddingY = parseFloat(containerStyle.paddingTop) + parseFloat(containerStyle.paddingBottom); const buttonsHeight = document.getElementById('canvasButtonContainer')?.offsetHeight || 0; const statusHeight = statusEl?.offsetHeight || 0; const maxWidth = container.clientWidth - paddingX - 2; const maxHeight = container.clientHeight - paddingY - buttonsHeight - statusHeight - 12; const aspectRatio = imgWidth / imgHeight; let newWidth = Math.min(imgWidth, maxWidth); let newHeight = newWidth / aspectRatio; if (newHeight > maxHeight) { newHeight = maxHeight; newWidth = newHeight * aspectRatio; } newWidth = Math.max(10, Math.floor(newWidth)); newHeight = Math.max(10, Math.floor(newHeight)); return { width: newWidth, height: newHeight }; }

        // --- MODIFIED getThreshold function ---
        function getThreshold() { // Renamed from getThresholds
            const t = parseFloat(document.getElementById('threshold').value) * 255;
            // console.log("Using threshold (internal value):", t); // Optional debug
            return t; // Return single value
        }
        // --- END MODIFIED getThreshold ---

        // --- Undo Functionality (No changes) ---
        function saveStateForUndo(actionDescription = "action") { /* ... same ... */ if (!masterImageData || isComposing) return; const stateToSave = new ImageData( new Uint8ClampedArray(masterImageData.data), masterImageData.width, masterImageData.height ); historyStack.push(stateToSave); if (historyStack.length > MAX_HISTORY) { historyStack.shift(); } updateUndoButtonState(); }
        function undoAction() { /* ... same ... */ if (historyStack.length === 0 || isComposing) { updateStatus(isComposing ? "Cannot undo while composing" : "Nothing to undo."); return; } const previousState = historyStack.pop(); masterImageData = previousState; displayMasterImage(); updateUndoButtonState(); updateStatus('Undo successful'); }

        // --- Keyboard Shortcuts (No changes) ---
        function setupKeyboardShortcuts() { /* ... same ... */ document.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); if (!undoButton.disabled) { undoAction(); } } }); }

        // --- Image Handling (Auto-compose logic unchanged) ---
        async function handleImageUpload(e) {
             // This function's logic remains the same as the previous version,
             // it calls composeImages() automatically after loading multiple images.
             // The changes are within composeImages() and getThreshold().
            /* ... same as previous step ... */
            const files = e.target.files; if (!files.length) { updateStatus('No files selected'); return; } setUIBusy(true); updateStatus(`Loading ${files.length} image(s)...`); resetApplicationState(false); let thumbnails = []; const MAX_IMAGES = 15; let shouldAutoCompose = false; try { for (let i = 0; i < Math.min(files.length, MAX_IMAGES); i++) { updateStatus(`Loading image ${i + 1} of ${Math.min(files.length, MAX_IMAGES)}: ${files[i].name}`); await new Promise(resolve => setTimeout(resolve, 0)); await imageStack.addImage(files[i]); const sourceImageData = imageStack.images[i]; if (!sourceImageData) continue; const tempSourceCanvas = document.createElement('canvas'); tempSourceCanvas.width = sourceImageData.width; tempSourceCanvas.height = sourceImageData.height; const tempSourceCtx = tempSourceCanvas.getContext('2d'); tempSourceCtx.putImageData(sourceImageData, 0, 0); const thumbCanvas = document.createElement('canvas'); thumbCanvas.width = 150; thumbCanvas.height = 112; const thumbCtx = thumbCanvas.getContext('2d'); thumbCtx.drawImage(tempSourceCanvas, 0, 0, tempSourceCanvas.width, tempSourceCanvas.height, 0, 0, 150, 112); const thumbImg = new Image(); thumbImg.src = thumbCanvas.toDataURL('image/png'); thumbImg.className = 'thumbnail'; thumbImg.title = `Layer ${i}: ${files[i].name} (${imageStack.width}x${imageStack.height})`; thumbImg.dataset.index = i; thumbnails.push(thumbImg); } if (imageStack.width > 0 && imageStack.height > 0) { canvas.width = imageStack.width; canvas.height = imageStack.height; console.log(`Main canvas element resized to ${canvas.width}x${canvas.height}`); } else if (files.length > 0) { updateStatus("Warning: Could not determine image dimensions.", true); } thumbnailStrip.innerHTML = ''; thumbnails.forEach(thumb => thumbnailStrip.appendChild(thumb)); let loadedCountMsg = `${imageStack.images.length} image${imageStack.images.length === 1 ? '' : 's'} loaded.`; if (files.length > MAX_IMAGES) { loadedCountMsg += ` (Processing limited to first ${MAX_IMAGES})`; } updateStatus(loadedCountMsg + ` Processing at ${imageStack.width}x${imageStack.height}.`); if (imageStack.images.length === 1) { masterImageData = imageStack.images[0]; displayMasterImage(); updateSaveButtonState(); updateComposeButtonState(); } else if (imageStack.images.length > 1) { if (masterImageData) { masterImageData = null; displayMasterImage(); } shouldAutoCompose = true; updateComposeButtonState(); updateSaveButtonState(); } else { updateComposeButtonState(); updateSaveButtonState(); } if (shouldAutoCompose) { console.log("Multiple images loaded, triggering automatic composition..."); updateStatus('Images loaded, starting automatic composition...'); await composeImages(); } } catch (error) { console.error('Error loading images:', error); updateStatus(`Error loading images: ${error.message || 'Unknown error'}`, true); resetApplicationState(false); } finally { setUIBusy(false); }
        }

        // --- composeImages Function (Uses single threshold) ---
        async function composeImages() {
            if (imageStack.images.length < 2) {
                updateStatus('Need at least two images to compose');
                return;
            }
            if (isComposing) {
                updateStatus("Composition already in progress.");
                return;
            }
            setUIBusy(true);
            updateStatus('Starting composition...');
            await new Promise(resolve => setTimeout(resolve, 10));
            // --- CHANGE: Get single threshold ---
            const threshold = getThreshold();
            // --- END CHANGE ---

            try {
                 // --- CHANGE: Pass single threshold to compose ---
                const { imageData, layerMatrix: lm } = await imageStack.compose(threshold);
                // --- END CHANGE ---
                masterImageData = imageData;
                layerMatrix = lm;
                historyStack = [];
                updateUndoButtonState();
                updateSaveButtonState();
                displayMasterImage();
                 // --- CHANGE: Update status message ---
                updateStatus(`Composition complete. Threshold: ${(threshold / 255).toFixed(2)}`);
                // --- END CHANGE ---
            } catch (error) {
                console.error('Composition failed:', error);
                updateStatus(`Error during composition: ${error.message}`, true);
                masterImageData = null;
                layerMatrix = null;
                updateSaveButtonState();
                displayMasterImage();
            } finally {
                setUIBusy(false);
            }
        }
        // --- END composeImages ---

        function displayMasterImage() { /* ... same ... */ ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#cccccc'; ctx.fillRect(0, 0, canvas.width, canvas.height); if (!masterImageData) { console.log("displayMasterImage: No master image data to display."); return; } if (masterImageData.width !== canvas.width || masterImageData.height !== canvas.height) { console.warn(`ImageData/canvas dimension mismatch detected in displayMasterImage. Resizing canvas to ${masterImageData.width}x${masterImageData.height}.`); canvas.width = masterImageData.width; canvas.height = masterImageData.height; ctx.fillStyle = '#cccccc'; ctx.fillRect(0, 0, canvas.width, canvas.height); } ctx.putImageData(masterImageData, 0, 0); console.log(`Displayed master image (${masterImageData.width}x${masterImageData.height}) on canvas.`); }

        // --- Canvas Interaction (Patch/Lasso) (Unchanged) ---
        function handleGlobalMouseMove(e) { /* ... same ... */ if (!drawingLasso || !masterImageData || isComposing) return; const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; const x = (e.clientX - rect.left) * scaleX; const y = (e.clientY - rect.top) * scaleY; const safeX = Math.max(0, Math.min(x, canvas.width - 1)); const safeY = Math.max(0, Math.min(y, canvas.height - 1)); const lastPoint = lassoPoints[lassoPoints.length-1]; if (!lastPoint || Math.abs(safeX - lastPoint.x) > 1 || Math.abs(safeY - lastPoint.y) > 1) { lassoPoints.push({x: safeX, y: safeY}); } redrawCanvasWithLasso(); }
        function handleGlobalMouseUp(e) { /* ... same ... */ if (!drawingLasso || !masterImageData || isComposing) return; window.removeEventListener('mousemove', handleGlobalMouseMove); window.removeEventListener('mouseup', handleGlobalMouseUp); drawingLasso = false; const modifierStillPressed = (isPatchLasso && e.ctrlKey) || (!isPatchLasso && e.altKey); if (!modifierStillPressed) { console.log("Modifier key released before mouse up, cancelling."); clearLassoAndRedraw(); updateStatus('Lasso cancelled (modifier key released).'); lassoPoints = []; return; } if (lassoPoints.length < 3) { console.log("Lasso too small, cancelling."); clearLassoAndRedraw(); updateStatus('Lasso too small, action cancelled.'); lassoPoints = []; return; } saveStateForUndo(isPatchLasso ? "patch lasso" : "blend lasso"); if (isPatchLasso) { applyLassoPatch(); } else { applyLassoBlend(); } }
        function setupCanvasEvents() { /* ... same ... */ canvas.addEventListener('mousedown', (e) => { if (isComposing || !masterImageData || (imageStack.images.length > 1 && !layerMatrix)) { updateStatus("Cannot interact: Not ready or composing."); return; } if (imageStack.images.length < 2 && !(e.ctrlKey || e.altKey)) { updateStatus("Need multiple images loaded and composed to patch/blend."); return; } const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; const x = Math.floor((e.clientX - rect.left) * scaleX); const y = Math.floor((e.clientY - rect.top) * scaleY); const safeX = Math.max(0, Math.min(x, canvas.width - 1)); const safeY = Math.max(0, Math.min(y, canvas.height - 1)); if (e.ctrlKey || e.altKey) { if (drawingLasso) return; if (imageStack.images.length < 2 || !layerMatrix) { updateStatus("Need composed image (multiple layers) to use lasso tools."); return; } drawingLasso = true; isPatchLasso = e.ctrlKey; lassoPoints = [{x: safeX, y: safeY}]; window.addEventListener('mousemove', handleGlobalMouseMove); window.addEventListener('mouseup', handleGlobalMouseUp); updateStatus(`Drawing ${isPatchLasso ? 'patch' : 'blend'} lasso... Release ${isPatchLasso ? 'Ctrl' : 'Alt'} or mouse to apply.`); redrawCanvasWithLasso(); } else { if (imageStack.images.length < 2 || !layerMatrix) return; saveStateForUndo("patch click"); patchRegion(safeX, safeY); displayMasterImage(); } }); }
        function patchRegion(clickX, clickY) { /* ... same ... */ if (!masterImageData || !layerMatrix || imageStack.images.length < 2) { return; } const w = masterImageData.width; const h = masterImageData.height; const halfPatch = Math.floor(PATCH_SIZE / 2); const patchX = Math.max(0, Math.min(clickX - halfPatch, w - PATCH_SIZE)); const patchY = Math.max(0, Math.min(clickY - halfPatch, h - PATCH_SIZE)); const matrixIndex = clickY * w + clickX; if (matrixIndex < 0 || matrixIndex >= layerMatrix.length) { updateStatus('Error: Patch coordinates invalid.', true); return; } const selectedLayer = layerMatrix[matrixIndex]; if (selectedLayer === undefined || selectedLayer >= imageStack.images.length) { updateStatus(`Error: Invalid layer data (${selectedLayer}) at patch location.`, true); return; } const sourceImage = imageStack.images[selectedLayer]; const sourceData = sourceImage.data; const targetData = masterImageData.data; let pixelsPatched = 0; for (let yOffset = 0; yOffset < PATCH_SIZE; yOffset++) { for (let xOffset = 0; xOffset < PATCH_SIZE; xOffset++) { const currentY = patchY + yOffset; const currentX = patchX + xOffset; if (currentY < h && currentX < w) { const targetIdx = (currentY * w + currentX) * 4; const sourceIdx = (currentY * w + currentX) * 4; if (targetIdx + 3 < targetData.length && sourceIdx + 3 < sourceData.length) { targetData[targetIdx] = sourceData[sourceIdx]; targetData[targetIdx + 1] = sourceData[sourceIdx + 1]; targetData[targetIdx + 2] = sourceData[sourceIdx + 2]; targetData[targetIdx + 3] = sourceData[sourceIdx + 3]; pixelsPatched++; } } } } updateStatus(`Patched ${pixelsPatched} pixels in ${PATCH_SIZE}x${PATCH_SIZE} region from layer ${selectedLayer} at (${clickX}, ${clickY})`); }
        function isPointInLasso(x, y, points) { /* ... same ... */ let inside = false; for (let i = 0, j = points.length - 1; i < points.length; j = i++) { const xi = points[i].x, yi = points[i].y; const xj = points[j].x, yj = points[j].y; const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi); if (intersect) inside = !inside; } return inside; }
        function redrawCanvasWithLasso() { /* ... same ... */ if (!masterImageData) return; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.putImageData(masterImageData, 0, 0); if (lassoPoints.length === 0) return; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y); for (let i = 1; i < lassoPoints.length; i++) { ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y); } if (isPatchLasso) { ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; ctx.strokeStyle = 'rgba(0, 100, 0, 0.7)'; } else { ctx.fillStyle = 'rgba(255, 255, 0, 0.3)'; ctx.strokeStyle = 'rgba(100, 100, 0, 0.7)'; } ctx.lineWidth = 1; if (lassoPoints.length > 2) { ctx.closePath(); ctx.fill(); } ctx.stroke(); if (lassoPoints.length > 0) { const lastPt = lassoPoints[lassoPoints.length - 1]; ctx.fillStyle = ctx.strokeStyle; ctx.fillRect(lastPt.x - 1, lastPt.y - 1, 3, 3); } ctx.globalAlpha = 1.0; }
        function clearLassoAndRedraw() { /* ... same ... */ displayMasterImage(); }
        function applyLassoPatch() { /* ... same ... */ if (!masterImageData || !layerMatrix || imageStack.images.length < 2 || lassoPoints.length < 3) { console.warn("Lasso patch conditions not met."); clearLassoAndRedraw(); return; } const w = masterImageData.width; const h = masterImageData.height; const minX = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.x)))); const maxX = Math.min(w - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.x)))); const minY = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.y)))); const maxY = Math.min(h - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.y)))); const startX = Math.floor(lassoPoints[0].x); const startY = Math.floor(lassoPoints[0].y); const startMatrixIndex = startY * w + startX; if (startMatrixIndex < 0 || startMatrixIndex >= layerMatrix.length) { updateStatus("Error: Invalid starting point for patch lasso.", true); console.error(`Invalid startMatrixIndex: ${startMatrixIndex}`); clearLassoAndRedraw(); lassoPoints = []; return; } const selectedLayer = layerMatrix[startMatrixIndex]; if (selectedLayer === undefined || selectedLayer >= imageStack.images.length) { updateStatus(`Error: Invalid layer data (${selectedLayer}) at patch lasso start.`, true); console.error(`Invalid selectedLayer: ${selectedLayer}`); clearLassoAndRedraw(); lassoPoints = []; return; } const sourceImage = imageStack.images[selectedLayer]; const sourceData = sourceImage.data; const targetData = masterImageData.data; let updatedPixels = 0; for (let y = minY; y <= maxY; y++) { for (let x = minX; x <= maxX; x++) { if (isPointInLasso(x + 0.5, y + 0.5, lassoPoints)) { const targetIdx = (y * w + x) * 4; const sourceIdx = (y * w + x) * 4; if (targetIdx + 3 < targetData.length && sourceIdx + 3 < sourceData.length) { targetData[targetIdx] = sourceData[sourceIdx]; targetData[targetIdx + 1] = sourceData[sourceIdx + 1]; targetData[targetIdx + 2] = sourceData[sourceIdx + 2]; targetData[targetIdx + 3] = sourceData[sourceIdx + 3]; updatedPixels++; } } } } displayMasterImage(); updateStatus(`Applied patch lasso from layer ${selectedLayer} (${updatedPixels} pixels).`); lassoPoints = []; }
        function applyLassoBlend() { /* ... same ... */ if (!masterImageData || imageStack.images.length < 2 || lassoPoints.length < 3) { console.warn("Lasso blend conditions not met."); clearLassoAndRedraw(); return; } const w = masterImageData.width; const h = masterImageData.height; const minX = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.x)))); const maxX = Math.min(w - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.x)))); const minY = Math.max(0, Math.floor(Math.min(...lassoPoints.map(p => p.y)))); const maxY = Math.min(h - 1, Math.ceil(Math.max(...lassoPoints.map(p => p.y)))); const targetData = masterImageData.data; const numLayers = imageStack.images.length; let updatedPixels = 0; for (let y = minY; y <= maxY; y++) { for (let x = minX; x <= maxX; x++) { if (isPointInLasso(x + 0.5, y + 0.5, lassoPoints)) { const targetIdx = (y * w + x) * 4; let r_sum = 0, g_sum = 0, b_sum = 0, a_sum = 0; for (let i = 0; i < numLayers; i++) { const sourceImage = imageStack.images[i]; if (!sourceImage) continue; const sourceData = sourceImage.data; const sourceIdx = (y * w + x) * 4; if (sourceIdx + 3 < sourceData.length) { r_sum += sourceData[sourceIdx]; g_sum += sourceData[sourceIdx + 1]; b_sum += sourceData[sourceIdx + 2]; a_sum += sourceData[sourceIdx + 3]; } else { a_sum += 255; } } if (targetIdx + 3 < targetData.length) { targetData[targetIdx] = Math.round(r_sum / numLayers); targetData[targetIdx + 1] = Math.round(g_sum / numLayers); targetData[targetIdx + 2] = Math.round(b_sum / numLayers); targetData[targetIdx + 3] = Math.round(a_sum / numLayers); updatedPixels++; } } } } displayMasterImage(); updateStatus(`Applied blend lasso across ${numLayers} layers (${updatedPixels} pixels).`); lassoPoints = []; }

        // --- Utility and Reset Functions ---
        // --- MODIFIED Tracy Rose Preset ---
        function setTracyRosePreset() {
            if (isComposing) return;
            const slider = document.getElementById('threshold');
            const valueDisplay = document.getElementById('threshold-value');
            if (slider && valueDisplay) {
                slider.value = 0.13; // Set the single slider
                valueDisplay.textContent = '0.13';
            }
            updateStatus('Tracy Rose preset applied (T=0.13). Click Compose to apply.');
            console.log('Tracy Rose preset applied');
        }
        // --- END MODIFIED Tracy Rose Preset ---

        // --- MODIFIED Reset Function ---
        function resetApplicationState(clearFileInput = true) {
            console.log("Resetting application state...");
            imageStack = new ImageStack();
            masterImageData = null;
            layerMatrix = null;
            lassoPoints = [];
            drawingLasso = false;
            historyStack = [];
            isComposing = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.width = 10; canvas.height = 10;
            displayMasterImage();
            if (clearFileInput && document.getElementById('imageInput')) {
                document.getElementById('imageInput').value = '';
            }
            thumbnailStrip.innerHTML = '';
            updateComposeButtonState();
            updateUndoButtonState();
            updateSaveButtonState();
            // --- CHANGE: Reset only one slider ---
            const slider = document.getElementById('threshold');
            const valueDisplay = document.getElementById('threshold-value');
            if (slider) slider.value = 0.05; // Reset to default
            if (valueDisplay) valueDisplay.textContent = '0.05';
            // --- END CHANGE ---
            setUIBusy(false);
        }
        // --- END MODIFIED Reset Function ---

        function resetApplication() { /* ... same ... */ resetApplicationState(true); updateStatus('Application reset. Upload images to begin.'); }
        function saveImage() { /* ... same ... */ if (!masterImageData) { updateStatus('No image to save', true); return; } if (isComposing) { updateStatus("Cannot save while composing.", true); return; } const tempCanvas = document.createElement('canvas'); tempCanvas.width = masterImageData.width; tempCanvas.height = masterImageData.height; const tempCtx = tempCanvas.getContext('2d'); tempCtx.putImageData(masterImageData, 0, 0); try { const dataURL = tempCanvas.toDataURL('image/png'); const link = document.createElement('a'); link.download = 'Aquiplicity_Master_OrigRes.png'; link.href = dataURL; document.body.appendChild(link); link.click(); document.body.removeChild(link); updateStatus(`Master image saved as ${link.download} (${masterImageData.width}x${masterImageData.height})`); console.log('Image saved'); } catch (error) { console.error("Error saving image:", error); updateStatus("Error saving image. Canvas might be too large or tainted.", true); } }

    </script>
</body>
</html>